<html>
<style>
    body {
        background-color: black;
        font-family: monospace;
        font-size: 10px;
        color: gray;
    }
    #stage {
    }
    .panelContainer {
        display: inline-block;
    }
    .panel {
        display: block;
        width: 50px; /* 24" */
        height: 100px; /* 48" */
        background-color: rgb(60, 0, 0);
        border: 1px solid #222222;
        margin: 5px;
    }
    .panelInfo {
        width: 50px; /* 24" */
        overflow-x: clip;
    }
    .panelReverberationInfo {
        display: inline-block;
        width: 50px;
        height: 20px;
        margin: 5px;
        border: 1px solid #222222;
    }
    #panelTemplate {
        display: none;
    }
    #reverberationInfoTemplate {
        display: none;
    }
    #panelReverberationInfoTemplate {
        display: none;
    }
    #gradient {
        display: block;
        width: 800px;
        height: 100px;
    }
    #gradientLineTemplate {
        display: none;
    }
    .gradientLine {
        display: inline-block;
        width: 4px;
        height: 100px;
        margin: 0;
        padding: 0;
    }
</style>
<body>
<div id="stage">
</div>
<div id="reverberationsInfo">
</div>
<div id="reverberationInfoTemplate" class="reverberationInfo">

</div>
<div id="panelReverberationInfoTemplate" class="panelReverberationInfo"></div>
<div id="gradient"></div>
<div id="panelTemplate" class="panelContainer">
    <div class="panel"></div>
    <div class="panelInfo">0</div>
</div>
<hr>
Event Loop: <input type="text" id="eventLoopInfo"/>
<hr>
<textarea id="triggerScript" rows="10" cols="100">
6 at 0ms
11 at 400ms
2 at 2000ms
</textarea>
<button id="triggerScriptButton" value="run">Run</button>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
  const NUMBER_OF_PANELS = 20;
  const PANEL_TEMPLATE_ELEMENT = document.getElementById("panelTemplate");
  const STAGE = document.getElementById("stage");
  const TRIGGER_SCRIPT_TEXTAREA = document.getElementById("triggerScript");
  const TRIGGER_SCRIPT_BUTTON = document.getElementById("triggerScriptButton");
  const EVENT_LOOP_INFO_ELEMENT = document.getElementById("eventLoopInfo");
  const REVERBERATIONS_INFO_ELEMENT = document.getElementById("reverberationsInfo");
  const REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("reverberationInfoTemplate");
  const PANEL_REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("panelReverberationInfoTemplate");

  function randomIntBetween(min, max) {
    return min + Math.round(Math.random() * (max - min));
  }

  function dimValueBy(value, amount, minLimit) {
    if (amount < 0) {
      return value;
    }
    if (!minLimit) {
      minLimit = 0;
    }
    return Math.max(minLimit, Math.round(value * (1 - amount)));
  }

  function clone(templateElement) {
    let clone = templateElement.cloneNode(true);
    clone.attributes.removeNamedItem("id");
    return clone;
  }

  function removeChildren(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function newPanel(index, context) {
    let panelElement = clone(PANEL_TEMPLATE_ELEMENT);
    panelElement.classList.add("panel-" + index);
    STAGE.appendChild(panelElement);
    return new Panel(panelElement, index, context);
  }

  class Color {
    constructor(red, green, blue) {
      this.red = red;
      this.green = green;
      this.blue = blue;
    }

    setMinRed(minRed) {
      this.minRed = minRed;
    }

    setMinGreen(minGreen) {
      this.minGreen = minGreen;
    }

    setMinBlue(minBlue) {
      this.minBlue = minBlue;
    }

    setMinColor(color) {
      this.setMinRed(color.red);
      this.setMinGreen(color.green);
      this.setMinBlue(color.blue);
    }

    dimBy(amount) {
      this.red = dimValueBy(this.red, amount, this.minRed);
      this.green = dimValueBy(this.green, amount, this.minGreen);
      this.blue = dimValueBy(this.blue, amount, this.minBlue);
    }

    interpolate(color) {
      let red = (this.red + color.red) / 2;
      let green = (this.green + color.green) / 2;
      let blue = (this.blue + color.blue) / 2;
      return new Color(red, green, blue);
    }

    toHexString() {
      return "#"
        + this.red.toString(16).padStart(2, "0")
        + this.green.toString(16).padStart(2, "0")
        + this.blue.toString(16).padStart(2, "0");
    }
  }

  class GradientValuePoint {
    constructor(value, colorValue) {
      this.value = value;
      this.colorValue = colorValue;
    }
  }

  class SingleGradientValueMap {
    constructor() {
      this.gradientValuePoints = []; // new ArrayList<GradientValuePoint>();
    }

    getColorAtValue(value) {
      //GradientValuePoint[] points = getGradientValuePointForValue(value);
      let points = this.getGradientValuePointsForValue(value);
      // console.log(points, "for", value);

      // ratio = zero-based value / range
      // ratio = val - min / max - min;
      let min = points[0].value;
      let max = points[1].value;
      let ratio = (value - min) / (max - min);

      // ints
      let minColor = points[0].colorValue;
      let maxColor = points[1].colorValue;

      // int
      let colorRange = maxColor - minColor;
      // double
      let colorValue =  colorRange * ratio;

      // int
      let color = minColor + Math.round(colorValue);
      if (color > 255) {
        return 255;
      } else if (color < 0) {
        return 0;
      }

      return color;
    }


    //GradientValuePoint[] getGradientValuePointForValue(double value) {
    getGradientValuePointsForValue(value) {
      let lowerPoint = null;
      let matchingPointsForValue = null;
      for (let i = 0; i < this.gradientValuePoints.length; i++) {
        let point = this.gradientValuePoints[i];
        if (value >= point.value) {
          lowerPoint = point;
        } else {
          if (lowerPoint == null) {
            matchingPointsForValue = [ point, point ];
          } else {
            matchingPointsForValue = [ lowerPoint, point ];
          }
          break;
        }
      }

      if (matchingPointsForValue) {
        return matchingPointsForValue;
      }

      // otherwise, use the max two points
      return [
        this.gradientValuePoints[this.gradientValuePoints.length - 2],
        this.gradientValuePoints[this.gradientValuePoints.length - 1]
      ];
    }

    addPoint(value, color) {
      let point = new GradientValuePoint(value, color);
      this.gradientValuePoints.push(point);
    }

    setGradientValuePoints(points) {
      this.gradientValuePoints = points;
    }

    reset() {
      this.gradientValuePoints.clear();
    }
  }

  class GradientValueMap {

    constructor() {
      this.redMap = new SingleGradientValueMap();
      this.greenMap = new SingleGradientValueMap();
      this.blueMap = new SingleGradientValueMap();
    }

    reset() {
      this.redMap.reset();
      this.greenMap.reset();
      this.blueMap.reset();
    }

    addRGBPoint(value, red, green, blue) {
      this.addRedPoint(value, red);
      this.addGreenPoint(value, green);
      this.addBluePoint(value, blue);
    }

    addRedPoint(value, color) {
      this.redMap.addPoint(value, color);
    }

    addGreenPoint(value, color) {
      this.greenMap.addPoint(value, color);
    }

    addBluePoint(value, color) {
      this.blueMap.addPoint(value, color);
    }

    getColorForValue(value) {
      let red = this.redMap.getColorAtValue(value);
      let green = this.greenMap.getColorAtValue(value);
      let blue = this.blueMap.getColorAtValue(value);
      return new Color(red, green, blue);
    }
  }

  function getBasicGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60,   0,   0);
    gradientValueMap.addRGBPoint(.3, 255,   0,   0);
    gradientValueMap.addRGBPoint(.6, 255,   0, 255);
    gradientValueMap.addRGBPoint(1,    0, 255, 255);

    return gradientValueMap;
  }

  function getStraightFireGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60,   0,   0);
    gradientValueMap.addRGBPoint(.4, 255,   0,   0);
    gradientValueMap.addRGBPoint(1,  255, 255,   0);

    return gradientValueMap;
  }

  function getRainbowGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60, 0,     0);
    gradientValueMap.addRGBPoint(.2, 255, 0,     0);
    gradientValueMap.addRGBPoint(.3, 255, 255,   0);
    gradientValueMap.addRGBPoint(.4,   0, 255,   0);
    gradientValueMap.addRGBPoint(.6,   0, 255, 255);
    gradientValueMap.addRGBPoint(.8,   0,   0, 255);
    gradientValueMap.addRGBPoint(1,  255,   0, 255);

    return gradientValueMap;
  }

  function getBlueGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRedPoint(0, 60);
    gradientValueMap.addGreenPoint(0, 0);
    gradientValueMap.addBluePoint(0, 0);

    gradientValueMap.addRedPoint(.3, 30);
    gradientValueMap.addGreenPoint(.3, 0);
    gradientValueMap.addBluePoint(.3, 100);

    gradientValueMap.addRedPoint(.6, 0);
    gradientValueMap.addGreenPoint(.6, 0);
    gradientValueMap.addBluePoint(.6, 180);

    gradientValueMap.addRedPoint(.8, 0);
    gradientValueMap.addGreenPoint(.8, 100);
    gradientValueMap.addBluePoint(.8, 220);

    gradientValueMap.addRedPoint(1, 0);
    gradientValueMap.addGreenPoint(1, 180);
    gradientValueMap.addBluePoint(1, 255);

    return gradientValueMap;
  }

  function getFireGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRedPoint(0, 60);
    gradientValueMap.addGreenPoint(0, 0);
    gradientValueMap.addBluePoint(0, 0);

    gradientValueMap.addRedPoint(.1, 100);
    gradientValueMap.addGreenPoint(.1, 0);
    gradientValueMap.addBluePoint(.1, 0);

    gradientValueMap.addRedPoint(.6, 200);
    gradientValueMap.addGreenPoint(.6, 0);
    gradientValueMap.addBluePoint(.6, 0);

    gradientValueMap.addRedPoint(.8, 255);
    gradientValueMap.addGreenPoint(.8, 0);
    gradientValueMap.addBluePoint(.8, 0);

    gradientValueMap.addRedPoint(1, 255);
    gradientValueMap.addGreenPoint(1, 255);
    gradientValueMap.addBluePoint(1, 0);

    return gradientValueMap;
  }

  function showDebugGradientElement(panel) {
    /*
    removeChildren(GRADIENT_ELEMENT);
    for (const step of Array(panel.steps).keys()) {
      let color = panel.getColorForValue(step / panel.steps);
      let gradientLineElement = clone(GRADIENT_LINE_TEMPLATE_ELEMENT);
      gradientLineElement.style.backgroundColor = color;
      GRADIENT_ELEMENT.appendChild(gradientLineElement);
    }
     */
  }

  class Range {
    constructor(min, max) {
      this.min = min;
      this.max = max;
    }

    randomDistribution(count) {
      let length = this.max - this.min;
      let divisionLength = length / count;
      let distribution = [];
      for (let i = 0; i < count; i++) {
        // TODO: constraints on window size here?
        let value = randomIntBetween(divisionLength * .2, divisionLength * 1.5);
        distribution[i] = Math.min(value, this.max);
      }

      return distribution;
    }

    randomIntBetween() {
      return randomIntBetween(this.min, this.max);
    }
  }

  class PanelReverberation {
    constructor(panel,
                reverberation) {
      this.panel = panel;
      this.reverberation = reverberation;
      this.startTick = null;
      this.elapsedDurationTicks = -1;
      this.reverberationConfig = this.panel.panelContext.reverberationConfig;
      this.currentValue = 0;
      this.distanceFromTrigger = this.reverberation.getDistanceFromTriggerToPanel(this.panel);
      this.scale = this._calculateScale();
    }

    _calculateScale() {
      if (this.panel === this.reverberation.sourcePanel) {
        return 1;
      } else {
        let maxDistance = this.reverberationConfig.maxReverberationDistance;
        return (maxDistance - this.distanceFromTrigger) / maxDistance;
      }
    }

    update(tick) {
      if (this.startTick == null) {
        this.startTick = tick;
      }

      if (this.isDone()) {
        return;
      }

      let durationTicks = this.reverberationConfig.triggerPanelDurationTicks;
      let halfDurationTicks = durationTicks / 2;
      this.elapsedDurationTicks = tick - this.startTick;
      if (this.elapsedDurationTicks < halfDurationTicks) {
        // on our way up
        this.currentValue = this.elapsedDurationTicks / halfDurationTicks;
      } else {
        // on our way down
        this.currentValue = (durationTicks - this.elapsedDurationTicks) / halfDurationTicks;
      }

      this.currentValue = this.currentValue * this.scale;
    }

    isDone() {
      return this.elapsedDurationTicks >= this.reverberationConfig.triggerPanelDurationTicks;
    }
  }

  class Reverberation {
    constructor(sourcePanel,
                reverberationConfig,
                panelContext) {
      this.sourcePanel = sourcePanel;
      this.reverberationConfig = reverberationConfig;
      this.panelContext = panelContext;
      this.panelReverberationsByPanelIndex = {};
      this.startTick = 0;

      this.panelReverberationsByPanelIndex[this.sourcePanel.index] = new PanelReverberation(this.sourcePanel, this);
      this._collectReverberatingPanels().forEach(panel => {
        this.panelReverberationsByPanelIndex[panel.index] = new PanelReverberation(panel, this)
      });
      this.panelReverberations = Object.values(this.panelReverberationsByPanelIndex);

      /*
      this.reverberationInfoElement = clone(REVERBERATION_INFO_TEMPLATE_ELEMENT);
      this.reverberationInfoElement.id = "reverberationInfo-" + this.sourcePanel.index;
      this.panelContext.panels.forEach(panel => {
        let panelReverberationInfoElement = clone(PANEL_REVERBERATION_INFO_TEMPLATE_ELEMENT);
        panelReverberationInfoElement.id = "panelReverberationInfo-" + this.sourcePanel.index + "-revPanel-" + panel.index;
        this.reverberationInfoElement.appendChild(panelReverberationInfoElement);
      });
      REVERBERATIONS_INFO_ELEMENT.appendChild(this.reverberationInfoElement);
       */
    }

    _collectReverberatingPanels() {
      let fromIndex = this.sourcePanel.index;
      let reverberatingPanels = [];
      for (let i = 0; i < this.reverberationConfig.maxReverberationDistance - 1; i++) {
        let distanceFromIndex = i + 1;
        let leftPanelIndex = fromIndex - distanceFromIndex;
        let rightPanelIndex = fromIndex + distanceFromIndex;

        if (leftPanelIndex >= 0) {
          reverberatingPanels[reverberatingPanels.length] = this.panelContext.getPanelAt(leftPanelIndex);
        }

        if (rightPanelIndex <= this.panelContext.panels.length - 1) {
          reverberatingPanels[reverberatingPanels.length] = this.panelContext.getPanelAt(rightPanelIndex);
        }
      }
      return reverberatingPanels;
    }

    start(tick) {
      this.startTick = tick;
    }

    update(tick) {
      this.panelReverberations.forEach(panelReverberation => {
        let reverberationPanelDelayTicks = this.reverberationConfig.reverberationPanelDelayTicks;
        let delayForPanelToStartTicks = panelReverberation.distanceFromTrigger * reverberationPanelDelayTicks;
        // Note: this.startTick is when the Reverberation starts, and this waits for a delay to start calculating values
        let totalElapsedTicks = tick - this.startTick;
        if (totalElapsedTicks >= delayForPanelToStartTicks) {
          // waited long enough from the trigger tick, start keeping track of the duration
          panelReverberation.update(tick)
        }
      });
    }

    isDead() {
      let activePanelReverberations = this.panelReverberations.filter(panelReverberation => !panelReverberation.isDone());
      return activePanelReverberations.length === 0;
    }

    getDistanceFromTriggerToPanel(panel) {
      return Math.abs(this.sourcePanel.index - panel.index);
    }

    getValueForPanel(panel) {
      return this.panelReverberationsByPanelIndex[panel.index].currentValue;
    }
  }

  class ReverberationConfig {
    constructor(maxReverberationDistance,
                reverberationPanelDelayTicks,
                triggerPanelDurationTicks) {
      this.maxReverberationDistance = maxReverberationDistance;
      this.reverberationPanelDelayTicks = reverberationPanelDelayTicks;
      this.triggerPanelDurationTicks = triggerPanelDurationTicks;
    }
  }

  class ReverberationContext {
    constructor(reverberationConfig, panelContext) {
      this.reverberationConfig = reverberationConfig;
      this.panelContext = panelContext;
    }

    createReverberation(panel) {
      return new Reverberation(
        panel,
        this.reverberationConfig,
        this.panelContext
      );
    }
  }

  class Panel {
    constructor(panelElement,
                index,
                panelContext) {
      this.panelContext = panelContext;
      this.panelElement = panelElement;
      this.panelUIElement = panelElement.querySelector("div[class='panel']");
      this.panelInfoElement = panelElement.querySelector("div[class='panelInfo']");
      this.index = index;
      this.idleColor = panelContext.idleGradient.getColorForValue(0);

      this.setColor(this.idleColor);
      panelElement.addEventListener("touch", () => this.triggerInteraction());
      panelElement.addEventListener("click", () => this.triggerInteraction());
    }

    getPanelReverberationInfoElement() {
      return this.panelElement.querySelector("div[id='panelReverberationInfo-" + this.index + "']");
    }

    reset() {
      this.setColor(this.idleColor);
    }

    triggerInteraction() {
      this.panelContext.onPanelTriggered(this);
      showDebugGradientElement(this);
    }

    /**
     * Update this Panel at the given tick, taking into account its current
     * state - is it triggered? Reverberating? Etc.
     * @param tick
     * @param reverberations
     */
    update(tick, reverberations) {
      this.setColor(this.nextColor(tick, reverberations));
    }

    setColor(color) {
      this.color = color;
      this.panelUIElement.style.backgroundColor = this.color.toHexString();
    }

    nextColor(tick, reverberations) {
      // TODO: something like reverberation.getPanelReverberation(this);
      let valueSums = 0;
      reverberations.forEach(reverberation => {
        let reverberationPanelValue = reverberation.getValueForPanel(this);
        // this.updatePanelReverberationInfo(reverberation, reverberationPanelValue);
        valueSums += reverberationPanelValue;
      });

      // this.panelInfoElement.innerText = valueSums.toString().substring(0, 4);
      return this.panelContext.idleGradient.getColorForValue(valueSums);
    }

    updatePanelReverberationInfo(reverberation, value) {
      let selectors = "div[id='panelReverberationInfo-" + reverberation.sourcePanel.index + "-revPanel-" + this.index + "']";
      let panelReverberationInfoElement = reverberation.reverberationInfoElement.querySelector(selectors);
      panelReverberationInfoElement.innerText = value.toString().substring(0, 4);
    }
  }

  class PanelContext {
    constructor(numberOfPanels,
                reverberationConfig,
                idleGradient) {
      this.numberOfPanels = numberOfPanels;
      this.reverberationConfig = reverberationConfig;
      this.reverberationContext = new ReverberationContext(reverberationConfig, this);
      this.idleGradient = idleGradient;
      this.panels = [];
      this.allActiveReverberations = [];
      this.tick = 0;
    }

    createPanels() {
      for (const index of Array(this.numberOfPanels).keys()) {
        this.panels.push(newPanel(index, this));
      }
    }

    getPanelAt(index) {
      return this.panels[index];
    }

    triggerPanel(panelIndex) {
      let panel = this.getPanelAt(panelIndex);
      panel.triggerInteraction();
    }

    _collectActivePanelReverberations() {
      let uniqueActivePanels = {} // gotta cleanup, tho
      this.allActiveReverberations.forEach(reverberation => {
        reverberation.panelReverberations.forEach(panelReverberation => {
          let panel = panelReverberation.panel;
          let reverberation = panelReverberation.reverberation;
          this._addPanelToActiveReverberations(panel, reverberation, uniqueActivePanels);
        });
      });

      return Object.values(uniqueActivePanels);
    }

    _addPanelToActiveReverberations(panel, reverberation, uniqueActivePanels) {
      if (!uniqueActivePanels[panel.index]) {
        uniqueActivePanels[panel.index] = {
          panel: panel,
          reverberations: []
        };
      }

      let panelReverberations = uniqueActivePanels[panel.index].reverberations
      panelReverberations[panelReverberations.length] = reverberation
    }

    onPanelTriggered(panel) {
      let reverberation = this.reverberationContext.createReverberation(panel);
      this.allActiveReverberations[this.allActiveReverberations.length] = reverberation;

      reverberation.start(this.tick);
      if (this.intervalId == null) {
        this.start();
      }
    }

    start() {
      this.intervalId = setInterval(() => this.eventLoop(), 1);
    }

    stop() {
      clearInterval(this.intervalId);
      this.intervalId = null;
      this.tick = 0; // may as well reset the tick count so we're not summing to infinity
      EVENT_LOOP_INFO_ELEMENT.value = "stopped";
    }

    eventLoop() {
      this.tick += 1;
      EVENT_LOOP_INFO_ELEMENT.value = "Running: " + this.tick;
      this.allActiveReverberations.forEach(reverberation => reverberation.update(this.tick));

      this._collectActivePanelReverberations().forEach(activePanelReverberations => {
        let panel = activePanelReverberations.panel;
        panel.update(
          this.tick,
          activePanelReverberations.reverberations
        );
      })

      this.reapDeadReverberations();
      if (this.allActiveReverberations.length === 0) {
        this.stop();
      }
    }

    reapDeadReverberations() {
      this.allActiveReverberations = this.allActiveReverberations.filter(reverberation => {
        if (reverberation.isDead()) {
          // REVERBERATIONS_INFO_ELEMENT.removeChild(reverberation.reverberationInfoElement);
          return false;
        } else {
          return true;
        }
      });
    }
  }

  EVENT_LOOP_INFO_ELEMENT.value = "stopped";

  const MAX_REVERBERATION_DISTANCE = 5;
  const REVERB_DELAY_TICKS = 20;
  const TRIGGER_PANEL_DURATION_TICKS = 200;

  let reverberationConfig = new ReverberationConfig(
    MAX_REVERBERATION_DISTANCE,
    REVERB_DELAY_TICKS,
    TRIGGER_PANEL_DURATION_TICKS
  );

  let panelContext = new PanelContext(
    NUMBER_OF_PANELS,
    reverberationConfig,
    getStraightFireGradient()
  );

  panelContext.createPanels();

  function runScript() {
    let triggers = TRIGGER_SCRIPT_TEXTAREA.value.split("\n");
    triggers.forEach(trigger => {
      let triggerCmd = trigger.split(" ");
      setTimeout(
        () => panelContext.triggerPanel(parseInt(triggerCmd[0])),
        parseInt(triggerCmd[2])
      );
    });
  }

  TRIGGER_SCRIPT_BUTTON.addEventListener("click", () => runScript());
});

</script>
</body>
</html>