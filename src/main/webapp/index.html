<html>
<style>
    body {
        background-color: black;
    }
    #stage {
    }
    .panel {
        display: inline-block;
        width: 50px; /* 24" */
        height: 100px; /* 48" */
        background-color: rgb(60, 0, 0);
        border: 1px solid #222222;
        margin: 5px;
    }
    #panelTemplate {
        display: none;
    }
    #gradient {
        display: block;
        width: 800px;
        height: 100px;
    }
    #gradientLineTemplate {
        display: none;
    }
    .gradientLine {
        display: inline-block;
        width: 4px;
        height: 100px;
        margin: 0;
        padding: 0;
    }
</style>
<body>
<div id="stage">
</div>
<div id="gradient"></div>
<div id="gradientLineTemplate" class="gradientLine"></div>
<div id="panelTemplate" class="panel"></div>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
  const NUMBER_OF_PANELS = 20;
  const PANEL_TEMPLATE_ELEMENT = document.getElementById("panelTemplate");
  const STAGE = document.getElementById("stage");
  const GRADIENT_ELEMENT = document.getElementById("gradient");
  const GRADIENT_LINE_TEMPLATE_ELEMENT = document.getElementById("gradientLineTemplate");

  function randomIntBetween(min, max) {
    return min + Math.round(Math.random() * (max - min));
  }

  function dimValueBy(value, amount, minLimit) {
    if (amount < 0) {
      return value;
    }
    if (!minLimit) {
      minLimit = 0;
    }
    return Math.max(minLimit, Math.round(value * (1 - amount)));
  }

  function clone(templateElement) {
    let clone = templateElement.cloneNode(true);
    clone.attributes.removeNamedItem("id");
    return clone;
  }

  function removeChildren(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function newPanel(index, context) {
    let panelElement = clone(PANEL_TEMPLATE_ELEMENT);
    panelElement.classList.add("panel");
    STAGE.appendChild(panelElement);
    return new Panel(panelElement, index, context);
  }

  class Color {
    constructor(red, green, blue) {
      this.red = red;
      this.green = green;
      this.blue = blue;
    }

    setMinRed(minRed) {
      this.minRed = minRed;
    }

    setMinGreen(minGreen) {
      this.minGreen = minGreen;
    }

    setMinBlue(minBlue) {
      this.minBlue = minBlue;
    }

    setMinColor(color) {
      this.setMinRed(color.red);
      this.setMinGreen(color.green);
      this.setMinBlue(color.blue);
    }

    dimBy(amount) {
      this.red = dimValueBy(this.red, amount, this.minRed);
      this.green = dimValueBy(this.green, amount, this.minGreen);
      this.blue = dimValueBy(this.blue, amount, this.minBlue);
    }

    toHexString() {
      return "#"
        + this.red.toString(16).padStart(2, "0")
        + this.green.toString(16).padStart(2, "0")
        + this.blue.toString(16).padStart(2, "0");
    }
  }

  class GradientValuePoint {
    constructor(value, colorValue) {
      this.value = value;
      this.colorValue = colorValue;
    }
  }

  class SingleGradientValueMap {
    constructor() {
      this.gradientValuePoints = []; // new ArrayList<GradientValuePoint>();
    }

    getColorAtValue(value) {
      //GradientValuePoint[] points = getGradientValuePointForValue(value);
      let points = this.getGradientValuePointsForValue(value);
      // console.log(points, "for", value);

      // ratio = zero-based value / range
      // ratio = val - min / max - min;
      let min = points[0].value;
      let max = points[1].value;
      let ratio = (value - min) / (max - min);

      // ints
      let minColor = points[0].colorValue;
      let maxColor = points[1].colorValue;

      // int
      let colorRange = maxColor - minColor;
      // double
      let colorValue =  colorRange * ratio;

      // int
      let color = minColor + Math.round(colorValue);
      if (color > 255) {
        return 255;
      } else if (color < 0) {
        return 0;
      }

      return color;
    }


    //GradientValuePoint[] getGradientValuePointForValue(double value) {
    getGradientValuePointsForValue(value) {
      let lowerPoint = null;
      let matchingPointsForValue = null;
      for (let i = 0; i < this.gradientValuePoints.length; i++) {
        let point = this.gradientValuePoints[i];
        if (value >= point.value) {
          lowerPoint = point;
        } else {
          if (lowerPoint == null) {
            matchingPointsForValue = [ point, point ];
          } else {
            matchingPointsForValue = [ lowerPoint, point ];
          }
          break;
        }
      }

      if (matchingPointsForValue) {
        return matchingPointsForValue;
      }

      // otherwise, use the max two points
      return [
        this.gradientValuePoints[this.gradientValuePoints.length - 2],
        this.gradientValuePoints[this.gradientValuePoints.length - 1]
      ];
    }

    addPoint(value, color) {
      let point = new GradientValuePoint(value, color);
      this.gradientValuePoints.push(point);
    }

    setGradientValuePoints(points) {
      this.gradientValuePoints = points;
    }

    reset() {
      this.gradientValuePoints.clear();
    }
  }

  class GradientValueMap {

    constructor() {
      this.redMap = new SingleGradientValueMap();
      this.greenMap = new SingleGradientValueMap();
      this.blueMap = new SingleGradientValueMap();
    }

    reset() {
      this.redMap.reset();
      this.greenMap.reset();
      this.blueMap.reset();
    }

    addRGBPoint(value, red, green, blue) {
      this.addRedPoint(value, red);
      this.addGreenPoint(value, green);
      this.addBluePoint(value, blue);
    }

    addRedPoint(value, color) {
      this.redMap.addPoint(value, color);
    }

    addGreenPoint(value, color) {
      this.greenMap.addPoint(value, color);
    }

    addBluePoint(value, color) {
      this.blueMap.addPoint(value, color);
    }

    getColorForValue(value) {
      let red = this.redMap.getColorAtValue(value);
      let green = this.greenMap.getColorAtValue(value);
      let blue = this.blueMap.getColorAtValue(value);
      return new Color(red, green, blue);
    }
  }

  function getBasicGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60,   0,   0);
    gradientValueMap.addRGBPoint(.3, 255,   0,   0);
    gradientValueMap.addRGBPoint(.6, 255,   0, 255);
    gradientValueMap.addRGBPoint(1,    0, 255, 255);

    return gradientValueMap;
  }

  function getStraightFireGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60,   0,   0);
    gradientValueMap.addRGBPoint(.4, 255,   0,   0);
    gradientValueMap.addRGBPoint(1,  255, 255,   0);

    return gradientValueMap;
  }

  function getRainbowGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60, 0,     0);
    gradientValueMap.addRGBPoint(.2, 255, 0,     0);
    gradientValueMap.addRGBPoint(.3, 255, 255,   0);
    gradientValueMap.addRGBPoint(.4,   0, 255,   0);
    gradientValueMap.addRGBPoint(.6,   0, 255, 255);
    gradientValueMap.addRGBPoint(.8,   0,   0, 255);
    gradientValueMap.addRGBPoint(1,  255,   0, 255);

    return gradientValueMap;
  }

  function getBlueGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRedPoint(0, 60);
    gradientValueMap.addGreenPoint(0, 0);
    gradientValueMap.addBluePoint(0, 0);

    gradientValueMap.addRedPoint(.3, 30);
    gradientValueMap.addGreenPoint(.3, 0);
    gradientValueMap.addBluePoint(.3, 100);

    gradientValueMap.addRedPoint(.6, 0);
    gradientValueMap.addGreenPoint(.6, 0);
    gradientValueMap.addBluePoint(.6, 180);

    gradientValueMap.addRedPoint(.8, 0);
    gradientValueMap.addGreenPoint(.8, 100);
    gradientValueMap.addBluePoint(.8, 220);

    gradientValueMap.addRedPoint(1, 0);
    gradientValueMap.addGreenPoint(1, 180);
    gradientValueMap.addBluePoint(1, 255);

    return gradientValueMap;
  }

  function getFireGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRedPoint(0, 60);
    gradientValueMap.addGreenPoint(0, 0);
    gradientValueMap.addBluePoint(0, 0);

    gradientValueMap.addRedPoint(.1, 100);
    gradientValueMap.addGreenPoint(.1, 0);
    gradientValueMap.addBluePoint(.1, 0);

    gradientValueMap.addRedPoint(.6, 200);
    gradientValueMap.addGreenPoint(.6, 0);
    gradientValueMap.addBluePoint(.6, 0);

    gradientValueMap.addRedPoint(.8, 255);
    gradientValueMap.addGreenPoint(.8, 0);
    gradientValueMap.addBluePoint(.8, 0);

    gradientValueMap.addRedPoint(1, 255);
    gradientValueMap.addGreenPoint(1, 255);
    gradientValueMap.addBluePoint(1, 0);

    return gradientValueMap;
  }

  function showGradientElement(panel) {
    removeChildren(GRADIENT_ELEMENT);
    for (const step of Array(panel.steps).keys()) {
      let color = panel.getColorForValue(step / panel.steps);
      let gradientLineElement = clone(GRADIENT_LINE_TEMPLATE_ELEMENT);
      gradientLineElement.style.backgroundColor = color;
      GRADIENT_ELEMENT.appendChild(gradientLineElement);
    }
  }

  class Range {
    constructor(min, max) {
      this.min = min;
      this.max = max;
    }

    randomDistribution(count) {
      let length = this.max - this.min;
      let divisionLength = length / count;
      let distribution = [];
      for (let i = 0; i < count; i++) {
        // TODO: constraints on window size here?
        let value = randomIntBetween(divisionLength * .2, divisionLength * 1.5);
        distribution[i] = Math.min(value, this.max);
      }

      return distribution;
    }

    randomIntBetween() {
      return randomIntBetween(this.min, this.max);
    }
  }

  class Reverberation {
    constructor(panelIndex, delayMs, distance) {
      this.panelIndex = panelIndex;
      this.delayMs = delayMs;
      this.distance = distance;
    }
  }

  class ReverberationConfig {
    constructor(maxReverberationDistance,
                reverberationDelayMs,
                numberOfPanels) {
      this.maxReverberationDistance = maxReverberationDistance;
      this.reverberationDelayMs = reverberationDelayMs;
      this.maxPanelIndex = numberOfPanels - 1;
    }

    getReverberations(fromIndex) {
      let reverberations = [];
      let delayMs = this.reverberationDelayMs;
      for (let i = 0; i < this.maxReverberationDistance; i++) {
        // two at a time
        let distanceFromIndex = i + 1;
        let leftPanelIndex = fromIndex - distanceFromIndex;
        let rightPanelIndex = fromIndex + distanceFromIndex;

        delayMs += this.reverberationDelayMs * i;

        if (leftPanelIndex >= 0) {
          reverberations[reverberations.length] = new Reverberation(
            leftPanelIndex,
            delayMs,
            distanceFromIndex
          )
        }

        if (rightPanelIndex <= this.maxPanelIndex) {
          reverberations[reverberations.length] = new Reverberation(
            rightPanelIndex,
            delayMs,
            distanceFromIndex
          )
        }
      }
      return reverberations;
    }
  }

  class Panel {
    constructor(panelElement, index, context) {
      this.context = context;
      this.panelElement = panelElement;
      this.index = index;
      this.direction = true;
      this.tick = 0;
      this.steps = 100;
      this.gradientValueMap = context.idleGradient;
      this.intervalId = null;
      this.reverberating = false;
      this.reverberationDistance = 0;
      this.idleColor = this.gradientValueMap.getColorForValue(0);

      panelElement.addEventListener("touch", () => this.triggerInteraction());
      panelElement.addEventListener("click", () => this.triggerInteraction());
    }

    reset() {
      this.setColor(this.idleColor);
      clearInterval(this.intervalId);
      this.reverberating = false;
      this.reverberationDistance = 0;
      this.intervalId = null;
      this.tick = 0;
      this.direction = true;
    }

    triggerInteraction() {
      if (this.reverberating) {
        // TODO: don't reset the color - fade from current color to target color (in general need to allow for panel color to interpolate to some other color, as the interaction color will be complex combination of colors)
        this.reset();
      }

      if (this.intervalId == null) {
        this.steps = 100;
        this.reverberating = false;
        this.startAnimation();
        showGradientElement(this);
        this.triggerNeighborReverberations();
      } else {
        // TODO: overlap, what if I'm reverberating?
      }
    }

    triggerNeighborReverberations() {
      let reverberations = this.context.reverberationConfig.getReverberations(this.index);
      for (let i = 0; i < reverberations.length; i++) {
        let reverberation = reverberations[i];
        let neighborPanel = this.context.getPanelAt(reverberation.panelIndex);
        setTimeout(
          () => neighborPanel.triggerReverberation(reverberation.distance),
          reverberation.delayMs);
      }
    }

    triggerReverberation(distanceFromTriggeringPanel) {
      if (this.intervalId == null) {
        // TODO: slow this down, less jittery, give time for overlap
        this.steps = 100;
        this.reverberating = true;
        this.reverberationDistance = distanceFromTriggeringPanel;
        this.startAnimation();
      } else {
        // TODO: what if I'm triggered? wave overlap - interpolate new colors
      }
    }

    startAnimation() {
      this.tick = 0;
      // TODO: this.animationFrameMs
      this.intervalId = setInterval(() => this.animateStep(), 1);
    }

    animateStep() {
      if (this.direction) {
        this.tick += 1;
      } else {
        this.tick -= 1;
      }
      this.setColor(this.nextColor());
      if (this.direction) {
        if (this.tick >= this.steps) {
          this.direction = false;
        }
      } else {
        if (this.tick === 0) {
          this.reset();
        }
      }
    }

    setColor(color) {
      this.panelElement.style.backgroundColor = color.toHexString();
    }

    nextColor() {
      let value = this.tick / this.steps;
      return this.getColorForValue(value);
    }

    getColorForValue(value) {
      if (this.reverberating) {
        let max = this.context.reverberationConfig.maxReverberationDistance;
        let amount = (max - this.reverberationDistance) / max;
        return this.gradientValueMap.getColorForValue(value * amount);
      } else {
        return this.gradientValueMap.getColorForValue(value);
      }
    }
  }

  class PanelContext {
    constructor(numberOfPanels,
                reverberationConfig,
                idleGradient) {
      this.reverberationConfig = reverberationConfig;
      this.numberOfPanels = numberOfPanels;
      this.idleGradient = idleGradient;
      this.panels = [];
    }

    createPanels() {
      for (const index of Array(this.numberOfPanels).keys()) {
        this.panels.push(newPanel(index, this));
      }
    }

    getPanelAt(index) {
      return this.panels[index];
    }
  }

  const MAX_REVERBERATION_DISTANCE = 5;
  const reverberationDelayMs = 50;

  let panelContext = new PanelContext(
    NUMBER_OF_PANELS,
    new ReverberationConfig(
      MAX_REVERBERATION_DISTANCE,
      reverberationDelayMs,
      NUMBER_OF_PANELS),
    getStraightFireGradient()
  );
  panelContext.createPanels();
});

</script>
</body>
</html>