<html>
<body>
<style>
    body {
        background-color: black;
        font-family: monospace;
        color: gray;
    }
    #stage {
    }
    .panelContainer {
        display: inline-block;
        min-height: 1px;
    }
    .panel {
        display: block;
        width: 50px; /* 24" */
        height: 100px; /* 48" */
        background-color: rgb(60, 0, 0);
        border: 1px solid #222222;
        margin: 5px;
    }
    .panelInfo {
        display: block;
        width: 50px; /* 24" */
        height: 50px;
        overflow-x: clip;
        text-align: center;
        padding-left: 6px; /* align it center, for some reason */
    }
    .panelReverberationInfo {
        display: inline-block;
        width: 50px;
        height: 20px;
        margin: 5px;
        border: 1px solid #222222;
    }
    #panelTemplate {
        display: none;
    }
    .controlTable tr td {
        border: 1px solid #333333;
        vertical-align: top;
        padding: 5px;
    }
    .gradient-slice {
        display: inline-block;
        width: 1px;
        height: 100px;
    }
</style>
<div id="stage"></div>
<div id="panelTemplate" class="panelContainer">
    <div class="panel"></div>
    <div class="panelInfo">&nbsp;</div>
</div>
Click on a panel to simulate a person interacting with a panel. Click on the panel again to simulate a person walking away from the panel.
<hr/>
<table class="controlTable">
    <tr>
        <td>
            <p>
                <label for="triggerScript">Panel interaction script</label>
            </p>
            <textarea id="triggerScript" rows="10" cols="30">
3 at 0ms for 1500ms
8 at 200ms for 2000ms
6 at 500ms for 3000ms
7 at 600ms for 3000ms
9 at 1000ms for 5000ms
10 at 1500ms for 2000ms
11 at 2000ms for 2000ms
12 at 3000ms for 3000ms
</textarea>
            <p>
                <button id="triggerScriptButton" value="run">Run</button>
            </p>
        </td>
        <td>
            <p>
                Preset Scripts
            </p>
            <p>
                <button id="triggerWalkDownButton">Walk Left to Right</button>
            </p>
            <p>
                <button id="triggerMaxInteractionsButton">Max Interactions</button>
            </p>
            <p>
                <button id="clearInteractionsButton">Clear Interactions</button>
            </p>
        </td>
        <td>
            <p>
                Elapsed Time
            </p>
            <p id="elapsedTimeElement"></p>
            <p>
                Loop Time
            </p>
            <p id="loopTime"></p>
        </td>
        <td>
            <p>
                Current Power Draw: <span id="currentPowerDraw"></span>
            </p>
            <p>
                Max Power Draw: <span id="maxPowerDraw"></span>
            </p>
            <p>
                Ave Power Draw: <span id="averagePowerDraw"></span>
            </p>
        </td>
    </tr>
    <tr>
        <td colspan="4" id="gradientContainer">
        </td>
    </tr>
</table>
<div id="gradientTemplate"></div>
<script>
document.addEventListener("DOMContentLoaded",
  () => {

    /******************************************************************
     * Arduino.h
     *****************************************************************/

    HIGH = true;

    function millis() {
      return Date.now();
    }

    function abs(val) {
      return Math.abs(val);
    }

    function min(a, b) {
      return Math.min(a, b);
    }

    function max(a, b) {
      return Math.max(a, b);
    }

    function round(value) {
      return Math.round(value);
    }

    function send_colors(i, red, green, blue) {
      PANEL_UI_OBJECTS[i].setColor(red, green, blue);
    }

    /******************************************************************
     * Maths
     *****************************************************************/

    function maybe(percent) {
      return Math.round(Math.random() * 100) > percent;
    }

    function constrain(minValue, maxValue, value) {
      return max(minValue, min(maxValue, value));
    }

    function interpolateValue(value_a, value_b, amount) {
      let value_a_amount = value_a * (1.0 - amount);
      let value_b_amount = value_b * amount;

      return round(value_a_amount + value_b_amount);
    }

    /******************************************************************
     * Color
     *****************************************************************/

    function limit(red, green, blue) {
      let diff = (red + green + blue) - 510;
      if (diff > 0) {
        let mult = 1 - (diff / 510);
        return new Color(
          red * mult,
          green * mult,
          blue * mult);
      }
      return new Color(red, green, blue);
    }

    const gamma8 = [
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
      3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6,
      6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10,
      10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,
      17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,
      25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,
      37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,
      51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,
      69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,
      90, 92, 93, 95, 96, 98, 99, 101, 102, 104, 105, 107, 109, 110, 112, 114,
      115, 117, 119, 120, 122, 124, 126, 127, 129, 131, 133, 135, 137, 138, 140, 142,
      144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 167, 169, 171, 173, 175,
      177, 180, 182, 184, 186, 189, 191, 193, 196, 198, 200, 203, 205, 208, 210, 213,
      215, 218, 220, 223, 225, 228, 231, 233, 236, 239, 241, 244, 247, 249, 252, 255];

    class Color {
      constructor(red, green, blue, hue, saturation, lightness) {
        this.red = constrain(0, 255, round(red));
        this.green = constrain(0, 255, round(green));
        this.blue = constrain(0, 255, round(blue));

        this.hue = hue;
        this.saturation = saturation;
        this.lightness = lightness;
      }

      interpolate(color, amount) {
        let red = interpolateValue(this.red, color.red, amount);
        let green = interpolateValue(this.green, color.green, amount);
        let blue = interpolateValue(this.blue, color.blue, amount);

        let hue = (this.hue + color.hue) / 2;
        let saturation = (this.saturation + color.saturation) / 2;
        let lightness = (this.lightness + color.lightness) / 2;

        return new Color(red, green, blue, hue, saturation, lightness);
      }
    }

    /******************************************************************
     * GradientValuePoint
     *****************************************************************/

    class GradientValuePoint {
      constructor(value, colorValue) {
        this.value = value;
        this.colorValue = colorValue;
      }
    }

    /******************************************************************
     * SingleGradientValueMap
     * Defines a single color value gradient
     *****************************************************************/

    class SingleGradientValueMap {
      constructor() {
        this.gradientValuePoints = []; // new ArrayList<GradientValuePoint>();
      }

      getColorAtValue(value) {
        let points = this.getGradientValuePointsForValue(value);

        // ratio = zero-based value / range
        // ratio = val - min / max - min;
        let min = points[0].value;
        let max = points[1].value;
        let ratio = (value - min) / (max - min);

        // ints
        let minColor = points[0].colorValue;
        let maxColor = points[1].colorValue;

        // int
        let colorRange = maxColor - minColor;
        // double
        let colorValue = colorRange * ratio;

        // int
        let color = minColor + Math.round(colorValue);
        return Math.min(255, Math.max(0, color));
      }


      getGradientValuePointsForValue(value) {
        let lowerPoint = null;
        let matchingPointsForValue = null;
        for (let i = 0; i < this.gradientValuePoints.length; i++) {
          let point = this.gradientValuePoints[i];
          if (value >= point.value) {
            lowerPoint = point;
          } else {
            if (lowerPoint == null) {
              matchingPointsForValue = [point, point];
            } else {
              matchingPointsForValue = [lowerPoint, point];
            }
            break;
          }
        }

        if (matchingPointsForValue) {
          return matchingPointsForValue;
        }

        // otherwise, use the max two points
        return [
          this.gradientValuePoints[this.gradientValuePoints.length - 2],
          this.gradientValuePoints[this.gradientValuePoints.length - 1]
        ];
      }

      addPoint(value, color) {
        let point = new GradientValuePoint(value, color);
        this.gradientValuePoints.push(point);
      }

      setGradientValuePoints(points) {
        this.gradientValuePoints = points;
      }

      reset() {
        this.gradientValuePoints.clear();
      }
    }

    /******************************************************************
     * LinearGradientValueMap
     * defines a single-value RGB gradient
     *****************************************************************/

    class LinearGradientValueMap {

      constructor() {
        this.redMap = new SingleGradientValueMap();
        this.greenMap = new SingleGradientValueMap();
        this.blueMap = new SingleGradientValueMap();

        this.hueMap = new SingleGradientValueMap();
        this.saturationMap = new SingleGradientValueMap();
        this.lightnessMap = new SingleGradientValueMap();
      }

      reset() {
        this.redMap.reset();
        this.greenMap.reset();
        this.blueMap.reset();

        this.hueMap.reset();
        this.saturationMap.reset();
        this.lightnessMap.reset();
      }

      add_rgb_point(value, red, green, blue) {
        this.addRedPoint(value, red);
        this.addGreenPoint(value, green);
        this.addBluePoint(value, blue);

        let shiftedRed = red / 255;
        let shiftedGreen = green / 255;
        let shiftedBlue = blue / 255;

        let colorMax = Math.max(shiftedRed, shiftedGreen, shiftedBlue);
        let colorMin = Math.min(shiftedRed, shiftedGreen, shiftedBlue);

        let delta = colorMax - colorMin;
        let hue = 0;

        if (delta == 0) {
          hue = 0;
        } else if (colorMax == shiftedRed) {
          hue = ((shiftedGreen - shiftedBlue) / delta) % 6;
        } else if (colorMax == shiftedGreen) {
          hue = (shiftedBlue - shiftedRed) / delta + 2;
        } else {
          hue = (shiftedRed - shiftedGreen) / delta + 4;
        }

        hue = Math.round(hue * 60);

        if (hue < 0) {
          hue += 360;
        }

        let lightness = (colorMax + colorMin) / 2;

        let saturation = delta == 0 ? 0 : delta / (1 - Math.abs(2 * lightness - 1));

        // scale to 0 - 255
        saturation = +Math.round(saturation * 100);
        lightness = +Math.round(lightness * 100);

        this.hueMap.addPoint(value, hue);
        this.saturationMap.addPoint(value, saturation);
        this.lightnessMap.addPoint(value, lightness);
      }

      addRedPoint(value, color) {
        this.redMap.addPoint(value, color);
      }

      addGreenPoint(value, color) {
        this.greenMap.addPoint(value, color);
      }

      addBluePoint(value, color) {
        this.blueMap.addPoint(value, color);
      }

      getColorForValue(value) {
        let red = this.redMap.getColorAtValue(value);
        let green = this.greenMap.getColorAtValue(value);
        let blue = this.blueMap.getColorAtValue(value);

        let hue = this.hueMap.getColorAtValue(value);
        let saturation = this.saturationMap.getColorAtValue(value);
        let lightness = this.lightnessMap.getColorAtValue(value);

        return new Color(red, green, blue, hue, saturation, lightness);
      }
    }

    /******************************************************************
     * TransitionAnimation
     * Utility to transition between gradients
     *****************************************************************/

    class TransitionAnimation {
      constructor(duration) {
        this.active;
        this.cycle;
        this.current_gradient;
        this.next_gradient;

        this.cycle = new Cycle(duration, ONE_SHOT_CYCLE, UP_ONLY_CYCLE);

        this.current_value = 0;
        this.active = false;
      }

      start(current_gradient, next_gradient) {
        this.current_gradient = current_gradient;
        this.next_gradient = next_gradient;
        // TODO: if this was already started, this will jump...
        // Note: restart() will reset the `iterations` so we can
        // determine whether the animation has run once vs not run yet.
        this.cycle.restart();
        this.active = true;
      }

      update() {
        if (!this.active) {
          return;
        }

        this.cycle.update();

        if (this.cycle.isDone()) {
          this.cycle.stop();
          this.active = false;
        }
      }

      is_done() {
        // how do I know if it's done? It has to have _run_ to be done.
        return this.cycle.isDone();
      }

      /**
       * Used to reset the state of the transition animation so it can
       * be started again, vs knowing it is done and has stopped.
       */
      reset() {
        this.cycle.reset();
      }

      get_color(panel_value) {
        let from_color = this.current_gradient.getColorForValue(panel_value);
        let to_color = this.next_gradient.getColorForValue(panel_value);

        let color = from_color.interpolate(to_color, this.cycle.current_value);

        return color;
      }
    }

    /******************************************************************
     * ColorManager
     * manages the color gradients and transitions between them based
     * on interaction percentage.
     *****************************************************************/

    class ColorManager {
      constructor(gradients, number_of_gradients, config) {
        this.config;
        this.intermediate_interaction_debounce;
        this.intermediate_transition_delay_timer;
        this.gradient_transition_animation;
        this.gradients;
        this.number_of_gradients;
        this.current_gradient_index;
        this.next_gradient_index;
        this.current_gradient;
        this.max_gradient_index;
        this.transition_active;

        this.config = config;
        this.gradients = gradients;
        this.number_of_gradients = number_of_gradients;
        // TODO: move debounce time to config
        this.intermediate_interaction_debounce = new Debounce(10);
        this.intermediate_transition_delay_timer = new Cycle(
          this.config.delay_for_gradient_transition_duration,
          ONE_SHOT_CYCLE,
          UP_ONLY_CYCLE
        );
        this.gradient_transition_animation = new TransitionAnimation(config.gradient_transition_animation_duration)
        this.current_gradient_index = 0;
        this.next_gradient_index = 0;
        this.current_gradient = this.gradients[this.current_gradient_index];
        this.max_gradient_index = this.number_of_gradients - 1;
        this.transition_active = false;
      }

      update(current_interaction_percent) {
        this.current_interaction_percent = current_interaction_percent;
        this._update_intermediate_transition_state();

        if (this.gradient_transition_animation.active) {
          // if the transition is active, update it's state/clock.
          this.gradient_transition_animation.update();
        } else if (this.gradient_transition_animation.is_done()) {
          // If the transition animation is done, swap the gradients to the next
          // gradient and reset the transition.
          this.gradient_transition_animation.reset();
          // TODO: make this a random time - and make it _minutes_
          this.intermediate_transition_delay_timer.restart(config.delay_for_gradient_transition_duration)
          this.current_gradient_index = this.next_gradient_index;
          this.current_gradient = this.gradients[this.current_gradient_index];
          this.transition_active = false;
          // TODO: ok, so the new problem is that this will constantly cycle through gradients because
          // there is no state where we say "don't run the timer and don't transition."
          // Note: which is probably fine because we always want to shift through
          // gradients, just on a long, random timescale. We don't have to, but that's
          // the best idea I've had so far.
          console.log("finished gradient transition!");
        }
      }

      get_color(value) {
        if (this.transition_active) {
          return this.gradient_transition_animation.get_color(value);
        } else {
          return this.current_gradient.getColorForValue(value);
        }
      }

      _update_intermediate_transition_state() {
        if (this._is_intermediate_interaction()) {
          // If we've reached the intermediate interaction level
          if (this.intermediate_transition_delay_timer.is_running()) {
            // if the delay cycle is running, update it's state
            this.intermediate_transition_delay_timer.update();
            if (this.intermediate_transition_delay_timer.isDone() && !this.transition_active) {
              // if the timer is done, and we're not transitioning, it is time to transition!
              this._start_gradient_transition();
            }
          } else {
            // Otherwise we haven't started the cycle to trigger
            // intermediate transition, so start that cycle.
            this.intermediate_transition_delay_timer.start();
          }
        } else {
          // if the intermediate interactivity isn't reached, stop the timer
          this.intermediate_transition_delay_timer.stop();
        }
      }

      /**
       * Start the intermediate gradient transition
       */
      _start_gradient_transition() {
        console.log("starting gradient transition!");
        this.transition_active = true;
        // Note: The intermediate_transition_delay_timer shoudl have stopped if isDone is true.
        // I think.
        this.next_gradient_index = this.current_gradient_index + 1;
        if (this.next_gradient_index == this.number_of_gradients) {
          // hit the max, loop around.
          this.next_gradient_index = 0;
        }

        let next_gradient = this.gradients[this.next_gradient_index];
        this.gradient_transition_animation.start(
          this.current_gradient,
          next_gradient
        );
      }

      _is_intermediate_interaction() {
        const currently_high = this.current_interaction_percent > this.config.intermediate_interaction_threshold_percent;
        return this.intermediate_interaction_debounce.update(currently_high);
      }

      _is_max_interaction() {
        return this.current_interaction_percent > this.config.intermediate_interaction_threshold_percent;
      }
    }

    /******************************************************************
     * ValueSmoothingFn
     * Uses a buffer to average values over a window
     *****************************************************************/

    class ValueSmoothingFn {
      constructor(window_size) {
        this.values;
        this.window_size;
        this.current_value_index;
        this.initializing;

        this.values = [];
        this.window_size = window_size;
        this.current_value_index = 0;
        this.initializing = true;
      }

      get_smoothed_value(new_value) {
        if (this.initializing) {
          // initialize the array to the new value - the first
          // time we call this method, it returns the value.
          for (let i = 0; i < this.window_size; i++) {
            this.values[i] = new_value;
          }
          this.initializing = false;
          // optimize: there's no need to do the rest of the buffer
          // math since it returns the new_value anyways.
          return new_value;
        }

        // to use the latest window_size values, plus the new_value,
        // this overwrites the previous value at the
        // current_value_index with the new_value. The
        // current_value_index represents the _oldest_ value
        // in the window.
        this.values[this.current_value_index] = new_value;

        // Once the oldest value is overwritten with the latest value,
        // the current_value_index is incremented to the _next_
        // oldest value, so that the next value will overwrite
        // the oldest value.
        this.current_value_index++;
        if (this.current_value_index >= this.window_size) {
          // write into the first
          this.current_value_index = 0;
        }

        let smoothed_value = 0;
        for (let i = 0; i < this.window_size; i++) {
          smoothed_value += this.values[i];
        }

        return smoothed_value / this.window_size;
      }
    }

    /******************************************************************
     * Range
     *****************************************************************/

    class Range {
      constructor(min, max) {
        this.min = min;
        this.max = max;
      }

      random_int_between() {
        return this.min + Math.round(Math.random() * (this.max - this.min));
      }
    }

    /******************************************************************
     * Clock
     * Stores a constant incrementing tick count used to determine
     * durations and make timing calculations. update() must be called
     * after calling start() or restart() to get the first tick.
     *****************************************************************/

    class Clock {
      constructor() {
        this.running = false;
        this.ticks = -1;
      }

      start() {
        this.running = true;
      }

      pause() {
        this.running = false;
      }

      stop() {
        this.running = false;
        this.ticks = -1;
      }

      restart() {
        this.running = true;
        this.ticks = -1;
      }

      update() {
        if (!this.running) {
          return;
        }

        if (this.ticks < 0) {
          this.ticks = 0;
        } else {
          this.ticks += 1;
        }
      }

      isPaused() {
        return !this.running && this.ticks > -1;
      }

      isStopped() {
        return !this.running && this.ticks < 0;
      }
    }

    /******************************************************************
     * Cycle
     * An LFO/Envelope-like utility that provides a continuously
     * changing value.May be set to a one-shot. Can be started,
     * paused, and stopped. Also provides a release to provide a
     * smooth return to 0.
     *****************************************************************/
    const ONE_SHOT_CYCLE = true;
    const LOOP_CYCLE = false;
    const UP_ONLY_CYCLE = 1;
    const UP_DOWN_CYCLE = 2;

    class Cycle {

      constructor(duration_ticks,
                  one_shot,
                  cycle_type
      ) {
        this.duration_ticks = 0;
        this.one_shot = false;
        this.cycle_type;
        this.release_phase;
        this.clock;
        this.current_value;
        this.iterations;

        this.duration_ticks = duration_ticks;
        this.one_shot = one_shot;
        this.cycle_type = cycle_type;
        this.clock = new Clock();
        this.release_phase = false;
        this.iterations = 0;
        this.current_value = 0;
      }

      /**
       * Starts the cycle (does nothing if already started).
       */
      start() {
        this.release_phase = false;
        // if the clock is on the falling side,
        // set it to the equidistant rising side
        if (!this.isRising()) {
          this.clock.ticks = max(0, this.clock.ticks = this.duration_ticks - this.clock.ticks % this.duration_ticks);
        }
        this.clock.start();
      }

      /**
       * Stops the cycle from running - does not "release" it!
       */
      stop() {
        this.clock.stop();
        this.current_value = 0;
        this.release_phase = false;
      }

      /**
       * Reset the cycle so it can be run again.
       */
      reset() {
        // The `iterations` tracks whether this cycle has run or not.
        this.iterations = 0;
      }

      /**
       * Triggers the "release" phase of the cycle, dropping the
       * value down to its minimum which will then stop the cycle.
       */
      release() {
        this.release_phase = true;
        if (this.isRising() && this.cycle_type == UP_DOWN_CYCLE) {
          // If we're on the rising side of the cycle, jump the clock ticks
          // to the next down cycle at the same point: if we're at tick 23
          // of a duration of 100, then we're jumping to clock tick 67
          // (100 - 23) and continuing on to finish the remaining duration
          // cycle of 100.
          //
          // If we're on the falling side of the cycle, just let it finish
          this.clock.ticks = max(0, this.clock.ticks = this.duration_ticks - this.clock.ticks % this.duration_ticks);
        }
      }

      /**
       * Update this Cycle to the next iteration of its clock. Even if
       * a Cycle is stopped, it may have a release duration.
       */
      update() {
        // always update the clock. If it's stopped, it's a no-op, otherwise ensures
        // the click is up-to-date before doing any calculations.
        this.clock.update();

        if (this.clock.isStopped()) {
          // if this cycle has stopped - it's no longer actively cycling, nor is it in the release state,
          // there's nothing to do.
          return;
        }

        if (this.clock.ticks > 0 && this.clock.ticks % this.duration_ticks == 0) {
          // we've hit run the entire duration length. Increment the number
          // of iterations.
          this.iterations += 1;

          if (this.one_shot || this.release_phase) {
            // If this is a one-shot or the "release" is done, the Cycle is done.
            // Stop the clock, and return.
            this.stop();
            return;
          }
        }

        let looping_elapsed_duration = this.clock.ticks % this.duration_ticks;
        if (this.cycle_type == UP_ONLY_CYCLE) {
          this.current_value = looping_elapsed_duration / this.duration_ticks;
        } else {
          let half_animation_loop_duration_ticks = round(this.duration_ticks / 2);
          if (looping_elapsed_duration <= half_animation_loop_duration_ticks) {
            this.current_value = looping_elapsed_duration / half_animation_loop_duration_ticks;
          } else {
            this.current_value = (this.duration_ticks - 1 - looping_elapsed_duration) / half_animation_loop_duration_ticks;
          }
        }
      }

      isRising() {
        if (this.cycle_type == UP_ONLY_CYCLE) {
          return true;
        }
        const relative_ticks = this.clock.ticks % this.duration_ticks;
        return relative_ticks < (this.duration_ticks / 2);
      }

      restart(new_duration_ticks) {
        if (new_duration_ticks) {
          this.duration_ticks = new_duration_ticks;
        }
        this.release_phase = false;
        this.iterations = 0;
        this.clock.restart();
      }

      /**
       * Returns true if the cycle is at its "zero" point.
       */
      isAtZeroPoint() {
        return this.clock.ticks % this.duration_ticks == 0;
      }

      isDone() {
        return this.one_shot && this.iterations > 0;
      }

      isStopped() {
        return this.clock.isStopped();
      }

      is_running() {
        return this.clock.running;
      }
    }

    /******************************************************************
     * Config
     *****************************************************************/
    class Config {
      constructor() {
      }

      init() {
        this.max_reverberation_distance = this.reverberation_distance_range.max;
        this.initial_trigger_panel_animation_loop_duration_ticks =
          (this.trigger_panel_animation_loop_duration_ticks_range.max + this.trigger_panel_animation_loop_duration_ticks_range.min) / 2;
      }

      getTriggerPanelAnimationLoopDurationTicks() {
        return this.trigger_panel_animation_loop_duration_ticks_range.random_int_between();
      }

      get_reverberation_distance() {
        return this.reverberation_distance_range.random_int_between();
      }
    }

    /******************************************************************
     * Pulse
     * Manages the relationship between a Sensor and a single Cycle
     * (LFO) used as one input to drive panel colors.
     *
     * 1. A Sensor manages the reading and debounce.
     * 2. An Interaction reads the Sensor state and manages the on/off
     *    of the Cycle (LFO/Env)
     * 3. Reverberation reads one or more Interactions and builds
     *    up the value for a set of Panels
     * 4. Aunisoma reads all the PanelReverberations, sums their values
     *    for each Panel, and selects the color from the gradient.
     *
     *****************************************************************/
    class Pulse {
      constructor(amplitude, duration, one_shot) {
        this.amplitude;
        this.active;
        this.current_value;
        this.cycle;

        this.amplitude = amplitude;
        this.active = false;
        this.current_value = 0;
        this.cycle = new Cycle(duration, one_shot, UP_DOWN_CYCLE);
      }

      update(active) {
        if (this.active && !active) {
          // interaction was active, and now is not.
          this.stop();
        } else if (!this.active && active) {
          // interaction was not active, and now is
          this.start();
        }

        // no matter if it's stopped or not, we're updating its tick
        this.cycle.update();
        this.current_value = this.cycle.current_value * this.amplitude;
      }

      start() {
        this.active = true;
        this.cycle.start();
      }

      stop() {
        this.active = false;
        this.cycle.release();
      }

      isAtZeroPoint() {
        return this.cycle.isAtZeroPoint();
      }

      isStopped() {
        return this.cycle.isStopped();
      }
    }

    /******************************************************************
     * Reverberation
     * Manages a set of Pulses that each generate a Cycle of values
     * that together form a wave-like "reverberation" values across
     * the set of Pulses.
     *****************************************************************/
    class Reverberation {
      constructor(sensor, config, panel_index) {
        this.sensor;
        this.config;
        this.panel_index;
        this.first_panel_index;
        this.last_panel_index;
        this.active;
        this.max_distance;
        this.delay;
        this.delay_complete;
        this.distance;
        this.delay_clock;
        this.pulses = [];

        this.sensor = sensor;
        this.config = config;
        this.panel_index = panel_index;
        this.first_panel_index = 0;
        this.last_panel_index = 0;
        this.active = false;
        this.delay_complete = false;
        this.max_distance = config.reverberation_distance_range.max;
        this.delay = config.reverberation_panel_delay_ticks;
        this.delay_clock = new Clock();

        this._calculate_new_distance();

        // number _per side_.
        let durationTicks = config.getTriggerPanelAnimationLoopDurationTicks();
        for (let i = 0; i < this.max_distance; i++) {
          const amplitude = (this.max_distance - i) / this.max_distance;
          // TODO: if the duration is the same, the lower amplitude colors shift slower. With the gamma map,
          //  that means those slow color changes are perceptible as "jank". Might have to fix the gamma to cycle
          //  through darker colors more quickly than the low-mids?
          //  I'd say the same cycle duration isn't as nice either - the further cycles through the colors slower,
          //  while the front panel cycles really quickly. It does pulse, but it's not as natural.
          // TODO: I think the delay should be a similar value or calc to the duration and amplitude to make a more natural flow.
          //  it looks janky when the far panel animates really quickly after a short delay.
          const one_shot = i == 0 ? LOOP_CYCLE : ONE_SHOT_CYCLE;
          this.pulses[i] = new Pulse(amplitude, durationTicks, one_shot);
        }
      }

      update() {
        // This method is tricky:
        // The order in which we call methods and read values on the associated
        // objects is important. Generally speaking, we have to manage the
        // active state of our clocks for this Reverberation. Then we have to
        // update the delay clock. Only then we can update the Pulses, and
        // only after we update the Pulses can we read their values and use
        // them.
        //
        // If the order is changed, or we change how states are updated, then
        // we end up with bugs where ticks don't reset, clocks are stopped,
        // and values aren't updated.

        // First, determine if this Reverberation should be started or
        // stopped based on the current sensor reading. This manages the
        // delay clock start/stop state, which is critical to ensure
        // the "distant" Pulses wait a certain number of ticks before
        // generating their Cycle value, creating the wave-like animation.
        if (this.active && !this.sensor.active) {
          // interaction was active, and now is not.
          this.stop();
        } else if (!this.active && this.sensor.active) {
          // interaction was not active, and now is
          this.start();
        }

        // Now, if the Reverberation is in an active state, and the
        // delay clock is running, update the delay clock's ticks.
        if (this.active && this.delay_clock.running) {
          this.delay_clock.update();
        }

        // Now that the delay clock is updated, we can use it to
        // update the Pulses.
        for (let i = 0; i < this.max_distance; i++) {
          const pulse = this.pulses[i];
          // calculate the delay for this Pulse
          const pulseDelay = this.delay * i;
          // check to see if the delay has comleted or the delay
          // clock has passed that number of ticks
          const waited_long_enough = this.delay_complete || this.delay_clock.ticks >= pulseDelay;

          // and calculate whether the Pulse should be "active" or not.
          // This allows the Pulse to determine what it's own "active" state
          // means rather than have the Reverberation read and interpret
          // the Pulse state.
          const pulse_active = this.active && i < this.distance && waited_long_enough;
          pulse.update(pulse_active);
        }

        // Only after we update the Pulses can we ask if the first
        // Pulse (corresponding to the origin interaction panel)
        // is at its zero point. If so, recalculate new Pulse
        // distance and re-start the Pulses.
        if (this.active) {
          if (this.pulses[0].isAtZeroPoint()) {
            this._restart_pulses();
          }
        }

        // Lastly, check to see if all the Pulse delays have passed. If
        // so, we can stop the delay clock and flag that the delay has
        // been completed, letting the Pulses run free.
        const delay_over = this._is_delay_complete();
        if (delay_over) {
          this.delay_complete = true;
          this.delay_clock.stop();
        }
      }

      start() {
        // Start the Reverberation means putting it into a state where
        // the delay clock starts running on the next update() call
        // and Pulses wait for their delay time to start their Cycle.
        this.active = true;
        this.delay_clock.restart();
        this.delay_complete = false;
      }

      stop() {
        this.active = false;
        this.delay_complete = false;
      }

      get_panel_value_for_panel_index(panel_index) {
        // Returns a value for the given panel index, based on
        // this Reverberation's Pulse values for their corresponding
        // Cycles.
        if (panel_index < this.first_panel_index || panel_index > this.last_panel_index) {
          return 0;
        }

        // given panel index of 0, and this panel index of 3, and distance of 2:
        // ? = 3 - 0 - outside of range!
        // 2 = 3 - 1
        // 1 = 3 - 2
        // 0 = 3 - 3
        // 1 = 3 - 4
        const pulse_index = abs(this.panel_index - panel_index);
        return this.pulses[pulse_index].current_value;
      }

      _restart_pulses() {
        // at this point the interaction just started or has looped.
        this._calculate_new_distance();
        this.delay_clock.restart();
        this.delay_complete = false;
      }

      _is_delay_complete() {
        return this.delay_clock.ticks > this.delay * this.distance;
      }

      _calculate_new_distance() {
        this.distance = this.config.get_reverberation_distance();
        this.first_panel_index = max(0, this.panel_index - this.distance + 1);
        this.last_panel_index = min(config.number_of_panels - 1, this.panel_index + this.distance - 1);
      }
    }

    /******************************************************************
     * Panel
     *****************************************************************/
    class Panel {
      constructor(index) {
        this.index;
        this.color;

        this.index = index;
        this.color = new Color(10, 0, 0);
      }
    }

    /******************************************************************
     * Aunisoma
     *****************************************************************/
    class Aunisoma {
      constructor(config,
                  maxAnimationGradient,
                  gradients,
                  number_of_gradients,
                  sensors) {
        this.config;
        this.sensors;
        this.number_of_panels;
        this.number_of_sensors;
        this.current_interaction_percent;
        this.panels;
        this.reverberations;
        this.panel_smoothing_functions;
        this.color_manager;

        this.config = config;
        this.sensors = sensors;
        this.number_of_panels = config.number_of_panels;
        this.number_of_sensors = config.number_of_sensors;
        this.current_interaction_percent = 0;
        this.panels = [];
        this.reverberations = [];
        this.panel_smoothing_functions = [];
        this.color_manager = new ColorManager(gradients, number_of_gradients, config);

        this._create_panels();
        this._create_reverberations();
        this._create_panel_smoothing_functions();
      }

      _create_panels() {
        for (let i = 0; i < this.number_of_panels; i++) {
          let panel = new Panel(i);
          panel.index = i;
          this.panels[i] = panel;
        }
      }

      _create_reverberations() {
        // TODO: for now we're only reading one of the two sensors. Eventually handle a Reverberation per sensor.
        for (let i = 0; i < number_of_panels; i++) {
          this.reverberations[i] = new Reverberation(sensors[i * 2], config, i);
        }
      }

      _create_panel_smoothing_functions() {
        const window_size = this.config.smoothing_fn_window_size;
        for (let i = 0; i < number_of_panels; i++) {
          this.panel_smoothing_functions[i] = new ValueSmoothingFn(window_size);
        }
      }

      get_panel_at(index) {
        return this.panels[index];
      }

      update() {
        this._calculate_interaction_percent();
        this.color_manager.update(this.current_interaction_percent);

        for (let reverberation_index = 0; reverberation_index < this.reverberations.length; reverberation_index++) {
          const reverberation = this.reverberations[reverberation_index];
          reverberation.update();
        }

        for (let panel_index = 0; panel_index < number_of_panels; panel_index++) {
          let panel_value = 0;
          const panel_smoothing_fn = this.panel_smoothing_functions[panel_index];

          for (let reverberation_index = 0; reverberation_index < this.reverberations.length; reverberation_index++) {
            const reverberation = this.reverberations[reverberation_index];
            panel_value += reverberation.get_panel_value_for_panel_index(panel_index);
          }

          const value = panel_smoothing_fn.get_smoothed_value(panel_value);
          const color = this._calculate_color_for_value(value);
          this.panels[panel_index].color = color;
        }
      }

      _calculate_color_for_value(value) {
        return this.color_manager.get_color(value);
      }

      _calculate_interaction_percent() {
        let active_sensor_count = 0;
        for (let i = 0; i < this.number_of_sensors; i++) {
          const sensor = this.sensors[i];
          if (sensor.active) {
            active_sensor_count++;
          }
        }
        this.current_interaction_percent = active_sensor_count / this.number_of_sensors;
      }
    }

    /******************************************************************
     * Debounce
     *
     * Utility to debounce boolean value
     *****************************************************************/
    class Debounce {
      constructor(debounce_ticks) {
        this.reading;
        this.last_debounce_time;
        this.previous_reading;
        this.debounce_ticks;

        this.reading = false;
        this.last_debounce_time = -1;
        this.previous_reading = false;
        this.debounce_ticks = debounce_ticks;
      }

      update(new_reading) {
        let currentMillis = millis();
        if (this.previous_reading != new_reading) {
          this.last_debounce_time = currentMillis;
        }

        if ((currentMillis - this.last_debounce_time) >= this.debounce_ticks) {
          // whatever the reading is at, it's been there for longer than the debounce
          // delay, so take it as the actual current state:
          if (this.reading != new_reading) {
            this.reading = new_reading;
          }
        }

        this.previous_reading = new_reading;

        return this.reading;
      }
    }

    /******************************************************************
     * Sensor
     * Manages reading a PIR sensor value from the protocol,
     * debouncing chaotic values (PIRs tend to be chaotic
     * 1 or 0, generally being sensitive to a high reading).
     * TODO: use a smoothing function too, and rounding up?
     * Would smoothing the value help trend to a low value
     * if it's noisy?
     *****************************************************************/
    DEBOUNCE_PIR_DELAY = 0; // ms debounce
    class Sensor {

      constructor() {
        this.debounce;
        this.active;

        this.debounce = new Debounce(DEBOUNCE_PIR_DELAY);
        this.active = false;
      }

      update(reading) {
        this.active = this.debounce.update(reading);
      }
    }

    /******************************************************************
     * Aunisoma-Sketch.ino
     *****************************************************************/
    let sensors = [];

    let number_of_panels = 20;
    let number_of_sensors = 40;
    let config = new Config();

    let maxAnimationGradient = new LinearGradientValueMap();
    let initial_gradient = new LinearGradientValueMap();
    let blue_gradient = new LinearGradientValueMap();
    let green_gradient = new LinearGradientValueMap();
    let purple_red_gradient = new LinearGradientValueMap();
    let green_blue_gradient = new LinearGradientValueMap();

    let gradients = [
      initial_gradient,
      blue_gradient,
      purple_red_gradient,
      green_blue_gradient,
      green_gradient
    ];

    let aunisoma;

    function setup() {
      maxAnimationGradient.add_rgb_point(0.00, 255, 0, 0);
      maxAnimationGradient.add_rgb_point(0.02, 255, 127, 0);
      maxAnimationGradient.add_rgb_point(0.20, 255, 255, 0);
      maxAnimationGradient.add_rgb_point(0.29, 200, 255, 0);
      maxAnimationGradient.add_rgb_point(0.30, 0, 255, 0);
      maxAnimationGradient.add_rgb_point(0.31, 0, 255, 127);
      maxAnimationGradient.add_rgb_point(0.40, 0, 255, 200);
      maxAnimationGradient.add_rgb_point(0.45, 0, 255, 255);
      maxAnimationGradient.add_rgb_point(0.59, 0, 120, 255);
      maxAnimationGradient.add_rgb_point(0.60, 0, 0, 255);
      maxAnimationGradient.add_rgb_point(0.61, 160, 0, 255);
      maxAnimationGradient.add_rgb_point(0.80, 255, 0, 255);
      maxAnimationGradient.add_rgb_point(0.80, 255, 0, 255);
      maxAnimationGradient.add_rgb_point(0.89, 255, 0, 200);
      maxAnimationGradient.add_rgb_point(1.00, 255, 0, 0);

      initial_gradient.add_rgb_point(0.0, 3, 0, 0);
      initial_gradient.add_rgb_point(.4, 255, 0, 0);
      initial_gradient.add_rgb_point(1.0, 255, 255, 0);
      initial_gradient.add_rgb_point(1.6, 0, 255, 255);
      initial_gradient.add_rgb_point(3, 0, 255, 255);

      blue_gradient.add_rgb_point(0.0, 0, 0, 10);
      blue_gradient.add_rgb_point(.4, 0, 0, 255);
      blue_gradient.add_rgb_point(.8, 255, 0, 255);
      blue_gradient.add_rgb_point(2, 255, 255, 0);
      blue_gradient.add_rgb_point(3, 255, 255, 0);

      green_gradient.add_rgb_point(0.0, 0, 10, 0);
      green_gradient.add_rgb_point(.4, 0, 255, 0);
      green_gradient.add_rgb_point(.8, 255, 255, 0);
      green_gradient.add_rgb_point(1.5, 255, 0, 255);
      green_gradient.add_rgb_point(3, 255, 0, 255);

      purple_red_gradient.add_rgb_point(0, 1, 0, 1);
      purple_red_gradient.add_rgb_point(.4, 255, 0, 255);
      purple_red_gradient.add_rgb_point(.85, 255, 0, 0);
      purple_red_gradient.add_rgb_point(1.2, 255, 255, 0);
      purple_red_gradient.add_rgb_point(3, 0, 255, 0);

      green_blue_gradient.add_rgb_point(0, 0, 3, 0);
      green_blue_gradient.add_rgb_point(.3, 0, 255, 0);
      green_blue_gradient.add_rgb_point(1, 0, 255, 255);
      green_blue_gradient.add_rgb_point(2, 0, 0, 255);
      green_blue_gradient.add_rgb_point(3, 255, 0, 255);

      config.number_of_panels = number_of_panels;
      config.number_of_sensors = number_of_sensors;
      config.reverberation_distance_range = new Range(2, 5);
      // how long to wait to trigger a neighbor Panel to reverberate
      config.reverberation_panel_delay_ticks = 20;
      // total duration of a pulse wave from low to high back to low
      config.trigger_panel_animation_loop_duration_ticks_range = new Range(80, 220);
      // How many sensors need to be high to trigger the max interaction state
      config.max_interaction_threshold_percent = .85;
      // how many sensors need to be high to trigger a gradient transition "intermediate" state
      config.intermediate_interaction_threshold_percent = .2;
      // how long to wait for a gradient transition
      // tODO: make this random and longer
      config.delay_for_gradient_transition_duration = 2000;

      // smoothing amount for panel values. In the web mockup, 10 is a
      // little jumpy, 30 is smooth, 100 blurs so that it never goes
      // back to 0 even when the Reverberation is active (which I like)
      config.smoothing_fn_window_size = 50;
      // How long it takes to transition from one gradient to another
      config.gradient_transition_animation_duration = 500;

      config.init();

      for (let i = 0; i < number_of_sensors; i++) {
        sensors[i] = new Sensor();
      }

      aunisoma = new Aunisoma(config, maxAnimationGradient, gradients, 5, sensors);
    }

    function loop() {
      let start = new Date().getTime();
      aunisoma.update();

      for (let i = 0; i < number_of_panels; i++) {
        let panel = aunisoma.get_panel_at(i);
        let color = panel.color;
        send_colors(i, color.red, color.green, color.blue);
      }

      LOOP_TIME_ELEMENT.innerText = Math.round(new Date().getTime() - start) + " ms";
    }

    /******************************************************************
     * Power Calculations/Utilities
     *****************************************************************/

      // TODO: capture average amp-hours over time for various interactions for nightly consumption
    const DRAW_PER_COLOR_PER_PANEL_AMPS = 0.8046715655;

    function calculatePowerDrawForColorAmps(color) {
      return (color / 255) * DRAW_PER_COLOR_PER_PANEL_AMPS;
    }

    function getPowerDrawAmps(red, green, blue) {
      return calculatePowerDrawForColorAmps(red)
        + calculatePowerDrawForColorAmps(green)
        + calculatePowerDrawForColorAmps(blue);
    }

    function addPowerDrawAmps(amps) {
      currentAmps += amps;
      totalAmps += amps;

      CURRENT_POWER_DRAW_ELEMENT.innerText = (currentAmps + "").substring(0, 4);
      if (currentAmps > maxAmps) {
        maxAmps = currentAmps;
        MAX_POWER_DRAW_ELEMENT.innerText = (maxAmps + "").substring(0, 4);
      }

      let averageAmps = totalAmps / iterations;
      AVERAGE_POWER_DRAW_ELEMENT.innerText = (averageAmps + "").substring(0, 4);
    }

    /******************************************************************
     * UI Code
     *****************************************************************/

    const PANEL_TEMPLATE_ELEMENT = document.getElementById("panelTemplate");
    const STAGE = document.getElementById("stage");

    const GRADIENT_CONTAINER_ELEMENT = document.getElementById("gradientContainer");
    const GRADIENT_TEMPLATE_ELEMENT = document.getElementById("gradientTemplate");

    const TRIGGER_SCRIPT_TEXTAREA = document.getElementById("triggerScript");
    const TRIGGER_SCRIPT_BUTTON = document.getElementById("triggerScriptButton");
    const TRIGGER_WALK_DOWN_BUTTON = document.getElementById("triggerWalkDownButton");
    document
      .getElementById("triggerMaxInteractionsButton")
      .addEventListener("click", () => triggerMaxInteraction());

    function triggerMaxInteraction() {
      let numberOfSensorsToTrigger = (config.max_interaction_threshold_percent * number_of_panels) + 1;
      let indexesToTrigger = {};
      while (Object.keys(indexesToTrigger).length < numberOfSensorsToTrigger) {
        let panelIndex;
        do {
          panelIndex = Math.min(19, Math.round(Math.random() * number_of_panels));
        } while (indexesToTrigger[panelIndex] != null);
        indexesToTrigger[panelIndex] = 1;
      }

      Object.keys(indexesToTrigger).forEach(s => {
        let i = parseInt(s);
        sensors[i * 2].update(true);
        PANEL_UI_OBJECTS[i].setActive(true);
      });
    }

    document
      .getElementById("clearInteractionsButton")
      .addEventListener("click", () => {
        for (let i = 0; i < sensors.length; i++) {
          sensors[i].update(false);
        }
        for (let i = 0; i < PANEL_UI_OBJECTS.length; i++) {
          PANEL_UI_OBJECTS[i].setActive(false);
        }
      });


    const CURRENT_POWER_DRAW_ELEMENT = document.getElementById("currentPowerDraw");
    const MAX_POWER_DRAW_ELEMENT = document.getElementById("maxPowerDraw");
    const AVERAGE_POWER_DRAW_ELEMENT = document.getElementById("averagePowerDraw");

    const ELAPSED_TIME_ELEMENT = document.getElementById("elapsedTimeElement");
    const LOOP_TIME_ELEMENT = document.getElementById("loopTime")

    // TODO: show which panels have someone interacting
    const REVERBERATIONS_INFO_ELEMENT = document.getElementById("reverberationsInfo");
    const REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("reverberationInfoTemplate");
    const PANEL_REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("panelReverberationInfoTemplate");

    function renderLinearGradient(name, gradient, max) {
      let rgbGradientElement = clone(GRADIENT_TEMPLATE_ELEMENT);
      let hslGradientElement = clone(GRADIENT_TEMPLATE_ELEMENT);

      let steps = 1000;
      for (let i = 0; i < steps; i++) {

        let color;
        if (max) {
          color = gradient.getColorForValue(i / steps);
        } else {
          color = gradient.getColorForValue(i / (steps / 2));
        }

        let rgbSpan = document.createElement("span");
        rgbSpan.setAttribute("class", "gradient-slice");
        rgbSpan.style.backgroundColor = toHexString(color.red, color.green, color.blue);
        rgbGradientElement.appendChild(rgbSpan);
      }

      let nameElement = document.createElement("p");
      nameElement.innerText = name;
      GRADIENT_CONTAINER_ELEMENT.appendChild(nameElement);
      GRADIENT_CONTAINER_ELEMENT.appendChild(rgbGradientElement);
      GRADIENT_CONTAINER_ELEMENT.appendChild(hslGradientElement);
    }

    function toHexString(red, green, blue) {
      return "#"
        + red.toString(16).padStart(2, "0")
        + green.toString(16).padStart(2, "0")
        + blue.toString(16).padStart(2, "0");
    }

    function toHSLString(hue, saturation, lightness) {
      return "hsl(" + hue + ", " + saturation + "%, " + lightness + "%)";
    }

    function clone(templateElement) {
      let clone = templateElement.cloneNode(true);
      clone.attributes.removeNamedItem("id");
      return clone;
    }

    function removeChildren(element) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    class PanelUI {
      constructor(index, panelElement) {
        this.index = index;
        this.panelElement = panelElement;
        this.panelUIElement = panelElement.querySelector("div[class='panel']");
        this.panelInfoElement = panelElement.querySelector("div[class='panelInfo']");
      }

      setActive(active) {
        if (active) {
          this.panelInfoElement.innerText = "Active";
        } else {
          this.panelInfoElement.innerHTML = "&nbsp;";
        }
      }

      setColor(red, green, blue) {
        // red = gamma8[red];
        // green = gamma8[green];
        // blue = gamma8[blue];
        this.panelUIElement.style.backgroundColor = toHexString(red, green, blue);
        addPowerDrawAmps(getPowerDrawAmps(red, green, blue));
      }
    }

    const PANEL_UI_OBJECTS = [];

    for (let i = 0; i < number_of_panels; i++) {
      let panelElement = clone(PANEL_TEMPLATE_ELEMENT);
      panelElement.classList.add("panel-" + i);
      STAGE.appendChild(panelElement);

      let panelUI = new PanelUI(i, panelElement);
      panelElement.addEventListener("click", () => {
        let sensor = sensors[i * 2];
        sensor.update(!sensor.active);
        panelUI.setActive(sensor.active);
      })

      PANEL_UI_OBJECTS[i] = panelUI;
    }

    let currentAmps = 0;
    let maxAmps = 0;
    let totalAmps = 0;
    let iterations = 0;
    const START_TIME = new Date().getTime();

    setup();

    renderLinearGradient("max_gradient", maxAnimationGradient, 1);
    renderLinearGradient("initial_gradient", initial_gradient);
    renderLinearGradient("blue_gradient", blue_gradient);
    renderLinearGradient("green_gradient", green_gradient);
    renderLinearGradient("purple_red_gradient", purple_red_gradient);
    renderLinearGradient("green_blue_gradient", green_blue_gradient);

    // const testCycle = new Cycle(100, LOOP_CYCLE);
    // testCycle.start();
    // for (let i = 0; i < 300; i++) {
    //   testCycle.update();
    //   if (i === 120) {
    //     testCycle.release();
    //   }
    //
    //   if (i === 135) {
    //     testCycle.start();
    //   }
    //   console.log(i, testCycle.current_value, testCycle.clock.ticks, testCycle.isRising() ? "rising" : "falling", testCycle.isAtZeroPoint() ? `zero point` : null);
    // }

    const mainRunInterval = setInterval(() => {
      currentAmps = 0;
      let elapsedSeconds = Math.round((new Date().getTime() - START_TIME) / 1000);
      if (elapsedSeconds > 59) {
        let elapsedMinutes = Math.round(elapsedSeconds / 60);
        ELAPSED_TIME_ELEMENT.innerText = elapsedMinutes + " minutes";
      } else {
        ELAPSED_TIME_ELEMENT.innerText = elapsedSeconds + " seconds";
      }

      loop();

      iterations++;
    }, 10);
  });

</script>
</body>
</html>
