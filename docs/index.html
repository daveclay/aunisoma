<html>
<body>
<style>
    body {
        background-color: black;
        font-family: monospace;
        color: gray;
    }
    #stage {
    }
    .panelContainer {
        display: inline-block;
        min-height: 1px;
    }
    .panel {
        display: block;
        width: 50px; /* 24" */
        height: 100px; /* 48" */
        background-color: rgb(60, 0, 0);
        border: 1px solid #222222;
        margin: 5px;
    }
    .panelInfo {
        display: block;
        width: 50px; /* 24" */
        height: 50px;
        overflow-x: clip;
        text-align: center;
        padding-left: 6px; /* align it center, for some reason */
    }
    .panelReverberationInfo {
        display: inline-block;
        width: 50px;
        height: 20px;
        margin: 5px;
        border: 1px solid #222222;
    }
    #panelTemplate {
        display: none;
    }
    .controlTable tr td {
        border: 1px solid #333333;
        vertical-align: top;
        padding: 5px;
    }
</style>
<div id="stage"></div>
<div id="panelTemplate" class="panelContainer">
    <div class="panel"></div>
    <div class="panelInfo">&nbsp;</div>
</div>
Click on a panel to simulate a person interacting with a panel. Click on the panel again to simulate a person walking away from the panel.
<hr/>
<table class="controlTable">
    <tr>
        <td>
            <p>
                <label for="triggerScript">Panel interaction script</label>
            </p>
            <textarea id="triggerScript" rows="10" cols="30">
3 at 0ms for 1500ms
8 at 200ms for 2000ms
6 at 500ms for 3000ms
7 at 600ms for 3000ms
9 at 1000ms for 5000ms
10 at 1500ms for 2000ms
11 at 2000ms for 2000ms
12 at 3000ms for 3000ms
</textarea>
            <p>
                <button id="triggerScriptButton" value="run">Run</button>
            </p>
        </td>
        <td>
            <p>
                Preset Scripts
            </p>
            <p>
                <button id="triggerWalkDownButton" value="run">Walk Left to Right</button>
            </p>
            <p>
                <button id="triggerMaxInteractionsButton" value="run">Max Interactions</button>
            </p>
        </td>
        <td>
            Event Loop: <input type="text" id="eventLoopInfo"/>
        </td>
        <td>
            <p>
                Current Power Draw: <input type="text" id="currentPowerDraw">
            </p>
            <p>
                Max Power Draw: <input type="text" id="maxPowerDraw">
            </p>
        </td>
    </tr>
</table>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
  const NUMBER_OF_PANELS = 20;
  const PANEL_TEMPLATE_ELEMENT = document.getElementById("panelTemplate");
  const STAGE = document.getElementById("stage");
  const TRIGGER_SCRIPT_TEXTAREA = document.getElementById("triggerScript");
  const TRIGGER_SCRIPT_BUTTON = document.getElementById("triggerScriptButton");
  const TRIGGER_WALK_DOWN_BUTTON = document.getElementById("triggerWalkDownButton");
  const TRIGGER_MAX_BUTTON = document.getElementById("triggerMaxInteractionsButton");
  const EVENT_LOOP_INFO_ELEMENT = document.getElementById("eventLoopInfo");


  const CURRENT_POWER_DRAW_ELEMENT = document.getElementById("currentPowerDraw");
  const MAX_POWER_DRAW_ELEMENT = document.getElementById("maxPowerDraw");

  // TODO: show which panels have someone interacting
  const REVERBERATIONS_INFO_ELEMENT = document.getElementById("reverberationsInfo");
  const REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("reverberationInfoTemplate");
  const PANEL_REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("panelReverberationInfoTemplate");

  // TODO: measure more accurately, whether this is linear
  const DRAW_PER_COLOR_PER_PANEL_AMPS = 0.8046715655;


  function randomIntBetween(min, max) {
    return min + Math.round(Math.random() * (max - min));
  }

  function calculatePowerDrawForColorAmps(color) {
    return (color / 255) * DRAW_PER_COLOR_PER_PANEL_AMPS;
  }

  function dimValueBy(value, amount, minLimit) {
    if (amount < 0) {
      return value;
    }
    if (!minLimit) {
      minLimit = 0;
    }
    return Math.max(minLimit, Math.round(value * (1 - amount)));
  }

  function clone(templateElement) {
    let clone = templateElement.cloneNode(true);
    clone.attributes.removeNamedItem("id");
    return clone;
  }

  function removeChildren(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function newPanel(index, context) {
    let panelElement = clone(PANEL_TEMPLATE_ELEMENT);
    panelElement.classList.add("panel-" + index);
    STAGE.appendChild(panelElement);
    return new Panel(panelElement, index, context);
  }

  class Color {
    constructor(red, green, blue) {
      this.red = red;
      this.green = green;
      this.blue = blue;
    }

    setMinRed(minRed) {
      this.minRed = minRed;
    }

    setMinGreen(minGreen) {
      this.minGreen = minGreen;
    }

    setMinBlue(minBlue) {
      this.minBlue = minBlue;
    }

    setMinColor(color) {
      this.setMinRed(color.red);
      this.setMinGreen(color.green);
      this.setMinBlue(color.blue);
    }

    dimBy(amount) {
      this.red = dimValueBy(this.red, amount, this.minRed);
      this.green = dimValueBy(this.green, amount, this.minGreen);
      this.blue = dimValueBy(this.blue, amount, this.minBlue);
    }

    interpolate(color) {
      let red = (this.red + color.red) / 2;
      let green = (this.green + color.green) / 2;
      let blue = (this.blue + color.blue) / 2;
      return new Color(red, green, blue);
    }

    getPowerDrawAmps() {
      return calculatePowerDrawForColorAmps(this.red)
        + calculatePowerDrawForColorAmps(this.green)
        + calculatePowerDrawForColorAmps(this.blue);
    }

    toHexString() {
      return "#"
        + this.red.toString(16).padStart(2, "0")
        + this.green.toString(16).padStart(2, "0")
        + this.blue.toString(16).padStart(2, "0");
    }
  }

  class GradientValuePoint {
    constructor(value, colorValue) {
      this.value = value;
      this.colorValue = colorValue;
    }
  }

  class SingleGradientValueMap {
    constructor() {
      this.gradientValuePoints = []; // new ArrayList<GradientValuePoint>();
    }

    getColorAtValue(value) {
      //GradientValuePoint[] points = getGradientValuePointForValue(value);
      let points = this.getGradientValuePointsForValue(value);

      // ratio = zero-based value / range
      // ratio = val - min / max - min;
      let min = points[0].value;
      let max = points[1].value;
      let ratio = (value - min) / (max - min);

      // ints
      let minColor = points[0].colorValue;
      let maxColor = points[1].colorValue;

      // int
      let colorRange = maxColor - minColor;
      // double
      let colorValue =  colorRange * ratio;

      // int
      let color = minColor + Math.round(colorValue);
      return Math.min(255, Math.max(0, color));
    }


    //GradientValuePoint[] getGradientValuePointForValue(double value) {
    getGradientValuePointsForValue(value) {
      let lowerPoint = null;
      let matchingPointsForValue = null;
      for (let i = 0; i < this.gradientValuePoints.length; i++) {
        let point = this.gradientValuePoints[i];
        if (value >= point.value) {
          lowerPoint = point;
        } else {
          if (lowerPoint == null) {
            matchingPointsForValue = [ point, point ];
          } else {
            matchingPointsForValue = [ lowerPoint, point ];
          }
          break;
        }
      }

      if (matchingPointsForValue) {
        return matchingPointsForValue;
      }

      // otherwise, use the max two points
      return [
        this.gradientValuePoints[this.gradientValuePoints.length - 2],
        this.gradientValuePoints[this.gradientValuePoints.length - 1]
      ];
    }

    addPoint(value, color) {
      let point = new GradientValuePoint(value, color);
      this.gradientValuePoints.push(point);
    }

    setGradientValuePoints(points) {
      this.gradientValuePoints = points;
    }

    reset() {
      this.gradientValuePoints.clear();
    }
  }

  class GradientValueMap {

    constructor() {
      this.redMap = new SingleGradientValueMap();
      this.greenMap = new SingleGradientValueMap();
      this.blueMap = new SingleGradientValueMap();
    }

    reset() {
      this.redMap.reset();
      this.greenMap.reset();
      this.blueMap.reset();
    }

    addRGBPoint(value, red, green, blue) {
      this.addRedPoint(value, red);
      this.addGreenPoint(value, green);
      this.addBluePoint(value, blue);
    }

    addRedPoint(value, color) {
      this.redMap.addPoint(value, color);
    }

    addGreenPoint(value, color) {
      this.greenMap.addPoint(value, color);
    }

    addBluePoint(value, color) {
      this.blueMap.addPoint(value, color);
    }

    getColorForValue(value) {
      let red = this.redMap.getColorAtValue(value);
      let green = this.greenMap.getColorAtValue(value);
      let blue = this.blueMap.getColorAtValue(value);
      return new Color(red, green, blue);
    }
  }

  function getBasicGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60,   0,   0);
    gradientValueMap.addRGBPoint(.3, 255,   0,   0);
    gradientValueMap.addRGBPoint(.6, 255,   0, 255);
    gradientValueMap.addRGBPoint(1,    0, 255, 255);

    return gradientValueMap;
  }

  function getGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,    60,   0,   0);
    gradientValueMap.addRGBPoint(.4,  255,   0,   0);
    gradientValueMap.addRGBPoint(1,   255, 255,   0);
    gradientValueMap.addRGBPoint(1.2,   0, 255,   0);
    gradientValueMap.addRGBPoint(1.5,   0, 255, 255);
    gradientValueMap.addRGBPoint(3.6,   0,   0, 255);
    gradientValueMap.addRGBPoint(4.5, 255,   0, 255);

    return gradientValueMap;
  }

  function getStraightFireGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60,   0,   0);
    gradientValueMap.addRGBPoint(.4, 255,   0,   0);
    gradientValueMap.addRGBPoint(1,  255, 255,   0);

    return gradientValueMap;
  }

  function getRainbowGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRGBPoint(0,   60, 0,     0);
    gradientValueMap.addRGBPoint(.2, 255, 0,     0);
    gradientValueMap.addRGBPoint(.3, 255, 255,   0);
    gradientValueMap.addRGBPoint(.4,   0, 255,   0);
    gradientValueMap.addRGBPoint(.6,   0, 255, 255);
    gradientValueMap.addRGBPoint(.8,   0,   0, 255);
    gradientValueMap.addRGBPoint(1,  255,   0, 255);

    return gradientValueMap;
  }

  function getBlueGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRedPoint(0, 60);
    gradientValueMap.addGreenPoint(0, 0);
    gradientValueMap.addBluePoint(0, 0);

    gradientValueMap.addRedPoint(.3, 30);
    gradientValueMap.addGreenPoint(.3, 0);
    gradientValueMap.addBluePoint(.3, 100);

    gradientValueMap.addRedPoint(.6, 0);
    gradientValueMap.addGreenPoint(.6, 0);
    gradientValueMap.addBluePoint(.6, 180);

    gradientValueMap.addRedPoint(.8, 0);
    gradientValueMap.addGreenPoint(.8, 100);
    gradientValueMap.addBluePoint(.8, 220);

    gradientValueMap.addRedPoint(1, 0);
    gradientValueMap.addGreenPoint(1, 180);
    gradientValueMap.addBluePoint(1, 255);

    return gradientValueMap;
  }

  function getFireGradient() {
    let gradientValueMap = new GradientValueMap();
    gradientValueMap.addRedPoint(0, 60);
    gradientValueMap.addGreenPoint(0, 0);
    gradientValueMap.addBluePoint(0, 0);

    gradientValueMap.addRedPoint(.1, 100);
    gradientValueMap.addGreenPoint(.1, 0);
    gradientValueMap.addBluePoint(.1, 0);

    gradientValueMap.addRedPoint(.6, 200);
    gradientValueMap.addGreenPoint(.6, 0);
    gradientValueMap.addBluePoint(.6, 0);

    gradientValueMap.addRedPoint(.8, 255);
    gradientValueMap.addGreenPoint(.8, 0);
    gradientValueMap.addBluePoint(.8, 0);

    gradientValueMap.addRedPoint(1, 255);
    gradientValueMap.addGreenPoint(1, 255);
    gradientValueMap.addBluePoint(1, 0);

    return gradientValueMap;
  }

  function showDebugGradientElement(panel) {
    /*
    removeChildren(GRADIENT_ELEMENT);
    for (const step of Array(panel.steps).keys()) {
      let color = panel.getColorForValue(step / panel.steps);
      let gradientLineElement = clone(GRADIENT_LINE_TEMPLATE_ELEMENT);
      gradientLineElement.style.backgroundColor = color;
      GRADIENT_ELEMENT.appendChild(gradientLineElement);
    }
     */
  }

  class Range {
    constructor(min, max) {
      this.min = min;
      this.max = max;
    }

    randomDistribution(count) {
      let length = this.max - this.min;
      let divisionLength = length / count;
      let distribution = [];
      for (let i = 0; i < count; i++) {
        // TODO: constraints on window size here?
        let value = randomIntBetween(divisionLength * .2, divisionLength * 1.5);
        distribution[i] = Math.min(value, this.max);
      }

      return distribution;
    }

    randomIntBetween() {
      return randomIntBetween(this.min, this.max);
    }
  }

  class Clock {
    constructor() {
      this.running = false;
      this.startTick = null;
      this.ticks = null;
    }

    start() {
      this.running = true;
    }

    stop() {
      this.running = false;
      this.startTick = null;
      this.ticks = null;
    }

    next() {
      if (!this.running) {
        // Don't confuse people by automatically running; next() can only be called after start()
        throw "Clock is not running";
      }

      if (this.startTick == null) {
        this.startTick = 0;
      }

      if (this.ticks == null) {
        this.ticks = 0;
      } else {
        this.ticks += 1;
      }
    }

    restart() {
      this.running = true;
      this.startTick = null;
      this.ticks = null;
    }
  }

  class Cycle {
    constructor(durationTicks,
                onUpFn,
                onDownFn,
                isOneShot) {
      this.durationTicks = durationTicks;
      this.onUpFn = onUpFn;
      this.onDownFn = onDownFn;
      this.isOneShot = isOneShot;
      this.clock = new Clock();
      this.iterations = 0;
    }

    start() {
      this.clock.start();
    }

    stop() {
      this.clock.stop();
    }

    isDone() {
      return this.isOneShot && this.iterations > 0;
    }

    next() {
      if (this.clock.ticks >= this.durationTicks) {
        this.iterations += 1;
        if (this.isOneShot) {
          this.stop();
          return;
        } else {
          // we're cycling; once this goes over the duration, we may as well reset back to 0
          this.clock.restart();
        }
      }

      this.clock.next();

      let halfAnimationLoopDurationTicks = this.durationTicks / 2; // for up and down
      let loopingElapsedDuration = this.clock.ticks % this.durationTicks;

      if (loopingElapsedDuration < halfAnimationLoopDurationTicks) {
        // on our way up
        let currentValue = loopingElapsedDuration / halfAnimationLoopDurationTicks;
        this.onUpFn(currentValue);
      } else {
        // on our way down
        let currentValue = (this.durationTicks - loopingElapsedDuration) / halfAnimationLoopDurationTicks;
        this.onDownFn(currentValue);
      }
    }

    jumpToDownCycle() {
      if (this.durationTicks >= this.clock.ticks) {
        // Don't "underun" the clock here: only jump down if it's meaningful to do so. This
        // shouldn't result in 0, otherwise we'll never hit a single iteration.
        // TODO: the problem with this is that this never gets to a zero point.
        this.clock.ticks = Math.max(0, this.durationTicks - this.clock.ticks);
      }
    }

    restart(durationTicks) {
      if (durationTicks) {
        this.durationTicks = durationTicks;
      }
      this.iterations = 0;
      this.clock.restart();
    }

    isAtZeroPoint() {
      return this.clock.ticks == null || (this.clock.ticks % this.durationTicks === 0);
    }
  }

  class PanelReverberation {
    constructor(panel,
                interaction) {
      this.panel = panel;
      this.interaction = interaction;
      this.interactionConfig = this.panel.panelContext.interactionConfig;
      let oneShot = !this.isSourceInteraction();
      this.cycle = new Cycle(
        this.interactionConfig.initialTriggerPanelAnimationLoopDurationTicks,
        (value) => this.onUpCycle(value),
        (value) => this.onDownCycle(value),
        oneShot
      );
      this.currentValue = 0;
      this.distanceFromTrigger = this.interaction.getDistanceFromTriggerToPanel(this.panel);
    }

    _calculateScale() {
      if (this.panel === this.interaction.sourcePanel) {
        return 1;
      } else {
        let maxDistance = this.interaction.currentReverberatingDistance;
        return (maxDistance - this.distanceFromTrigger) / maxDistance;
      }
    }

    isSourceInteraction() {
      return this.panel.index === this.interaction.sourcePanel.index;
    }

    start() {
      this.scale = this._calculateScale();
      this.cycle.restart();
      console.log("Started PanelReverberation", this);
    }

    stop() {
      this.cycle.stop();
      console.log("Stopped PanelReverberation", this);
    }

    onUpCycle(value) {
      // on our way up
      this._setValue(value);
      if (!this.interaction.sourcePanel.interactionActive && !this.cycle.isAtZeroPoint()) {
        // Fade out from where this animation loop is at by jumping the cycle to the down-side.
        this.cycle.jumpToDownCycle();
      }
    }

    onDownCycle(value) {
      // on our way down
      this._setValue(value);
    }

    _setValue(value) {
      this.currentValue = value * this.scale;
    }

    update() {
      this.cycle.next();
      if (this.isSourceInteraction() && this.panel.interactionActive && this._isAnimationLoopDone()) {
        this.cycle.restart(this.interactionConfig.getTriggerPanelAnimationLoopDurationTicks());
      }
    }

    _isAnimationLoopDone() {
      return this.cycle.isDone() || (this.cycle.iterations > 0 && this.cycle.isAtZeroPoint());
    }

    isDone() {
      if (this.isSourceInteraction() && this.panel.interactionActive) {
        return false;
      }

      if (!this.cycle.clock.running) {
        return true;
      }

      // Otherwise, this is waiting for the animation loop to be done.
      return this._isAnimationLoopDone();
    }
  }

  class Interaction {
    constructor(sourcePanel,
                interactionConfig,
                panelContext) {
      this.sourcePanel = sourcePanel;
      this.interactionConfig = interactionConfig;
      this.panelContext = panelContext;

      this.clock = new Clock();
      this._buildPanelReverberations();
    }

    _buildPanelReverberations() {
      this.sourcePanelReverberation = new PanelReverberation(this.sourcePanel, this);
      this.panelReverberationsByPanelIndex = {};
      this.panelReverberationsByPanelIndex[this.sourcePanel.index] = this.sourcePanelReverberation;
      this._collectAllNeighborPanels().forEach(panel => {
        this.panelReverberationsByPanelIndex[panel.index] = new PanelReverberation(panel, this)
      });

      this.panelReverberations = Object.values(this.panelReverberationsByPanelIndex);
    }

    _collectAllNeighborPanels() {
      let fromIndex = this.sourcePanel.index;
      let reverberatingPanels = [];
      for (let i = 0; i < this.interactionConfig.maxReverberationDistance- 1; i++) {
        let distanceFromIndex = i + 1;
        let leftPanelIndex = fromIndex - distanceFromIndex;
        let rightPanelIndex = fromIndex + distanceFromIndex;

        if (leftPanelIndex >= 0) {
          reverberatingPanels[reverberatingPanels.length] = this.panelContext.getPanelAt(leftPanelIndex);
        }

        if (rightPanelIndex <= this.panelContext.panels.length - 1) {
          reverberatingPanels[reverberatingPanels.length] = this.panelContext.getPanelAt(rightPanelIndex);
        }
      }
      return reverberatingPanels;
    }

    _calculateActivePanelReverberations() {
      return this.eligiblePanelReverberations.filter(panelReverberation => !panelReverberation.isDone());
    }

    start() {
      if (this.clock.running) {
        throw "Interaction is already started!";
      }
      this.clock.start();
      this._triggerNewReverberation({
        triggerSourcePanel: true
      });
      console.log("Started interaction", this);
    }

    /**
     * This gets called to trigger new _reverberations_, either initially when an interaction starts, or reviving
     * after a reverberation animation is done.
     * @param options
     * @private
     */
    _triggerNewReverberation(options) {
      this.currentReverberatingDistance = this.interactionConfig.getReverberationDistance();
      this.eligiblePanelReverberations = this.panelReverberations.filter(panelReverberation =>
        this.currentReverberatingDistance >= panelReverberation.distanceFromTrigger
      );

      console.log("triggering " + this.currentReverberatingDistance + " reverberating panels");
      this.eligiblePanelReverberations.forEach(panelReverberation => {
        if (options.triggerSourcePanel || !panelReverberation.isSourceInteraction()) {
          panelReverberation.start();
        }
      });
    }

    stop() {
      if (!this.clock.running) {
        return;
      }
      this.clock.stop();
      this.activePanelReverberations.forEach(panelReverberation => {
        // These are marked as done, but haven't been reaped because this happens after the update() method is called.
        // So at the last clock step, everything is done, this is called, and the final PanelReverberations are stopped.
        // We can't reap them within the update() method because they need to hold the value for the panels that is
        // set _after_ the update() method is called.
        panelReverberation.stop();
      });
      console.log("Stopped Interaction", this);
    }

    /**
     * Calculate this Interaction's values that will be used to set the Panels color.
     */
    update() {
      if (!this.clock.running) {
        return;
      }
      this.clock.next();
      // pretty sure this has to be calculated _before_ we call PanelReverberation.update()
      this.isAtZeroPoint = this._calculateIsAtZeroPoint()

      // Goes through the eligible PanelReverberations and figures out which ones are still "active" (where
      // isDone() returns false).
      this.activePanelReverberations = this._calculateActivePanelReverberations();
      this.activePanelReverberations.forEach(panelReverberation => {
        let reverberationPanelDelayTicks = this.interactionConfig.reverberationPanelDelayTicks;
        let delayForPanelToStartTicks = panelReverberation.distanceFromTrigger * reverberationPanelDelayTicks;
        // Note: this.startTick is when the Reverberation starts, and this waits for a delay to start calculating values
        if (this.clock.ticks >= delayForPanelToStartTicks) {
          panelReverberation.update();
        }
      });

      // TODO: calling PanelReverberation stop() here happens _before_ we figure out the value XXX
      this.activePanelReverberations.forEach(panelReverberation => {
        if (panelReverberation.isDone()) {
          panelReverberation.stop();
        }
      });

      // TODO: interestingly, this might revive some PanelReverberations before we set the Panel value.
      this._maybeRevivePanelReverberations();
    }

    /**
     * Calculates whether the PanelReverberations are at a "zero point" - meaning the animations are at 0.
     * @returns {boolean}
     * @private
     */
    _calculateIsAtZeroPoint() {
      let last = this._findLastRemainingAliveSourcePanelReverberation();
      return last != null && last.currentValue === 0;
    }

    /**
     * Returns the last PanelReverberation if only one last active one exists. Otherwise, null.
     * @returns {unknown|null}
     * @private
     */
    _findLastRemainingAliveSourcePanelReverberation() {
      let alive = this.panelReverberations.filter(panelReverberation => !panelReverberation.isDone());
      if (alive.length === 1) {
        return alive[0];
      } else {
        return null;
      }
    }

    /**
     * Maybe trigger new reverberation animations
     * @private
     */
    _maybeRevivePanelReverberations() {
      if (this.isAtZeroPoint && this.sourcePanel.interactionActive && Math.random() > .65) {
        // TODO: make probability a function in the interaction config
        // Restart the clock: since this is at zero point, the clock can restart at 0 and continue running.
        // Additionally, this means the revived new PanelReverberations will respect the delay from 0, not have
        // to recalculate each panel in a continually running clock.
        this.clock.restart();
        this._triggerNewReverberation({
          triggerSourcePanel: false
        });
      }
    }

    /**
     * Called after update(), this checks whether the Interaction is dead. This means not only the panel is no longer
     * active, but that the reverberation animation is done.
     * @returns {boolean}
     */
    isDead() {
      if (this.sourcePanel.interactionActive) {
        return false;
      }
      // after update() is called, the final active PanelReverberations may be "done".
      if (!this.activePanelReverberations) {
        return true;
      }
      return this.activePanelReverberations.filter(panelReverberation => !panelReverberation.isDone()).length === 0;
    }

    getDistanceFromTriggerToPanel(panel) {
      return Math.abs(this.sourcePanel.index - panel.index);
    }

    /**
     * Return this Interactoin's value for the given Panel. It basis this value on the PanelReverberation for
     * the given Panel.
     * @param panel
     * @returns {number|*}
     */
    getValueForPanel(panel) {
      // TODO: this is called after update() is called, and doesn't reference the _active_ PanelReverberations, and
      // even if it did, if we reap or recalculate PanelReverberation this logic would be incorrect... It just
      // happens to work out that the other non-active or "done" PanelReverbation return 0 for this value.
      return this.panelReverberationsByPanelIndex[panel.index].currentValue;
    }
  }

  class InteractionConfig {
    constructor(minReverberationDistance,
                maxReverberationDistance,
                reverberationPanelDelayTicks,
                minTriggerPanelAnimationLoopDurationTicks,
                maxTriggerPanelAnimationLoopDurationTicks,
                maxInteractionThresholdPercent) {
      this.maxReverberationDistance = maxReverberationDistance;
      this.reverberationDistanceRange = new Range(minReverberationDistance, maxReverberationDistance);
      this.reverberationPanelDelayTicks = reverberationPanelDelayTicks;
      this.triggerPanelAnimationLoopDurationTicksRange = new Range(minTriggerPanelAnimationLoopDurationTicks, maxTriggerPanelAnimationLoopDurationTicks);
      this.initialTriggerPanelAnimationLoopDurationTicks = (maxTriggerPanelAnimationLoopDurationTicks + minTriggerPanelAnimationLoopDurationTicks) / 2;
      this.maxInteractionThresholdPercent = maxInteractionThresholdPercent;
    }

    getReverberationDistance() {
      return this.reverberationDistanceRange.randomIntBetween();
    }

    getTriggerPanelAnimationLoopDurationTicks() {
      return this.triggerPanelAnimationLoopDurationTicksRange.randomIntBetween();
    }
  }

  class InteractionContext {
    constructor(interactionConfig, panelContext) {
      this.interactionConfig = interactionConfig;
      this.panelContext = panelContext;
    }

    createInteraction(panel) {
      return new Interaction(
        panel,
        this.interactionConfig,
        this.panelContext
      );
    }
  }

  class Panel {
    constructor(panelElement,
                index,
                panelContext) {
      this.panelContext = panelContext;
      this.interactionActive = false;
      this.index = index;
      this.idleColor = panelContext.idleGradient.getColorForValue(0);

      this.panelElement = panelElement;
      this.panelUIElement = panelElement.querySelector("div[class='panel']");
      this.panelInfoElement = panelElement.querySelector("div[class='panelInfo']");

      this.setColor(this.idleColor);

      panelElement.addEventListener("click", () => {
        if (this.interactionActive) {
          this.stopInteraction();
        } else {
          this.panelContext.triggerPanel(this);
        }
      });
    }

    startInteraction() {
      this.interactionActive = true;
      this.panelInfoElement.innerText = "Active";
    }

    stopInteraction() {
      this.interactionActive = false;
      this.panelInfoElement.innerHTML = "&nbsp;";
    }

    reset() {
      this.setColor(this.idleColor);
    }

    /**
     * Update this Panel at the given tick, taking into account its current
     * state - is it triggered? Reverberating? Etc.
     * @param panelValueSources
     */
    update(panelValueSources) {
      this.setColor(this.nextColor(panelValueSources));
    }

    setColor(color) {
      this.color = color;
      // TODO: Separate UI from logic?
      this.panelUIElement.style.backgroundColor = this.color.toHexString();
      this.panelContext.addPowerDrawAmps(color.getPowerDrawAmps());
    }

    nextColor(panelValueSources) {
      // TODO: we could do this in PanelContext, where it would know which PanelSources are valid, and how to mix gradients. The Panel doesn't know what's going on.
      let valueSums = 0;
      panelValueSources.forEach(panelValueSource => {
        let reverberationPanelValue = panelValueSource.getValueForPanel(this);
        valueSums += reverberationPanelValue;
      });

      return this.panelContext.idleGradient.getColorForValue(valueSums);
    }
  }

  class PanelInteractionCollector {
    constructor() {
      this.reset();
    }

    addPanelAndValueSource(panel, valueSource) {
      let valueSourcesInvolvingPanel = this._getValueSourcesForPanel(panel);
      valueSourcesInvolvingPanel.push(valueSource);
    }

    forEachPanelAndValueSources(fn) {
      Object.values(this.panelAndValueSourcesByPanelIndex).forEach(fn);
    }

    _getValueSourcesForPanel(panel) {
      if (!this.panelAndValueSourcesByPanelIndex[panel.index]) {
        this.panelAndValueSourcesByPanelIndex[panel.index] = {
          panel: panel,
          panelValueSources: []
        };
      }

      return this.panelAndValueSourcesByPanelIndex[panel.index].panelValueSources;
    }

    reset() {
      this.panelAndValueSourcesByPanelIndex = {};
    }
  }

  class PanelContext {
    constructor(numberOfPanels,
                interactionConfig,
                idleGradient) {
      this.numberOfPanels = numberOfPanels;
      this.interactionConfig = interactionConfig;
      this.interactionContext = new InteractionContext(interactionConfig, this);
      this.idleGradient = idleGradient;
      this.panels = [];
      this.interactionsBySourcePanelIndex = {};
      this._createPanels();
      this._createInteractions();
      this.maxInteractionAnimation = new MaxInteractionAnimation(this);
      this.isAtMaxInteractions = false;
      this.amps = 0;
      this.maxAmps = -1;
      this.panelInteractionCollector = new PanelInteractionCollector();
    }

    _createPanels() {
      for (const index of Array(this.numberOfPanels).keys()) {
        this.panels.push(newPanel(index, this));
      }
    }

    _createInteractions() {
      this.interactions = this.panels.map(panel => {
        let interaction = this.interactionContext.createInteraction(panel);
        this.interactionsBySourcePanelIndex[panel.index] = interaction;
        return interaction;
      });
    }

    getPanelAt(index) {
      return this.panels[index];
    }

    /**
     * Entry point
     * @param panel
     */
    triggerPanel(panel) {
      // debounce
      if (!panel.interactionActive) {
        panel.startInteraction();
        let interaction = this.interactionsBySourcePanelIndex[panel.index];
        if (!interaction.clock.running) {
          interaction.start();
        }
        if (this.intervalId == null) {
          this.start();
        }
      }
    }

    start() {
      this.intervalId = setInterval(() => this.eventLoop(), 20);
      EVENT_LOOP_INFO_ELEMENT.value = "running";
    }

    stop() {
      clearInterval(this.intervalId);
      this.intervalId = null;
      EVENT_LOOP_INFO_ELEMENT.value = "stopped";
    }

    addPowerDrawAmps(amps) {
      this.amps += amps;
    }

    eventLoop() {
      this.isAtMaxInteractions = this._calculateAtMaxInteraction();

      // TODO: tell it to stop? Maybe? Or will we lose its value before we render?
      // TODO: do we need a setup, calculate, render, teardown lifecycle steps? It's confusing to know when update is called vs when the color is set.

      this.panelInteractionCollector.reset();
      let activeInteractions = [];

      this.interactions.forEach(interaction => {
        // update the internal state of the Interaction
        // This must be first - the Interactions' state must be updated to determine whether it is _dead_ or not.
        interaction.update()
        // now that the internal state has been updated, determine whether it is dead and stop it if necessary.
        if (interaction.isDead()) {
          // TODO: Should Interaction call stop() itself after update() is called, and then this can just ask?
          interaction.stop();
        } else {
          activeInteractions.push(interaction);
          interaction.activePanelReverberations.forEach(panelReverberation => {
            let panel = panelReverberation.panel;
            let interaction = panelReverberation.interaction;

            if (this.isAtMaxInteractions) {
              // TODO: filterValueSource? only max does this?
              interaction = this.maxInteractionAnimation.filterInteraction(interaction);
            }
            this.panelInteractionCollector.addPanelAndValueSource(panel, interaction);
          });
        }
      });

      this.maxInteractionAnimation.update();

      if (this.maxInteractionAnimation.isRunning()) {
        // all Panels, both active and inactive, participate in the max animation
        this.panels.forEach(panel => {
          this.panelInteractionCollector.addPanelAndValueSource(panel, this.maxInteractionAnimation);
        })
      }

      this.panelInteractionCollector.forEachPanelAndValueSources(panelAndValueSources => {
        let panel = panelAndValueSources.panel;
        panel.update(
          panelAndValueSources.panelValueSources
        );
      });

      if (activeInteractions.length === 0) {
        this.stop();
      }

      this._updatePowerDraw();
    }

    _updatePowerDraw() {
      CURRENT_POWER_DRAW_ELEMENT.value = this.amps + "";
      if (this.maxAmps < this.amps) {
        this.maxAmps = this.amps;
        MAX_POWER_DRAW_ELEMENT.value = this.maxAmps + "";
      }
      this.amps = 0;
    }

    _calculateAtMaxInteraction() {
      let activePanels = this.panels.filter(panel => panel.interactionActive).length;
      let activePercent = activePanels / this.panels.length;
      return activePercent >= this.interactionConfig.maxInteractionThresholdPercent;
    }
  }

  class InteractionFilter {
    constructor(interaction) {
      this.interaction = interaction;
    }

    getValueForPanel(panel) {
      let originalValue = this.interaction.getValueForPanel(panel);
      return originalValue * .4;
    }
  }

  class MaxInteractionAnimation {

    constructor(panelContext) {
      this.panelContext = panelContext;
      this.cycle = new Cycle(
        // TODO: move duration to config
        500,
        (value) => this.onUpCycle(value),
        (value) => this.onDownCycle(value)
      );
      this.currentValue = 0;
      this.panelValuesByPanelIndex = {};
    }

    filterInteraction(interaction) {
      return new InteractionFilter(interaction);
    }

    isRunning() {
      if (this.panelContext.isAtMaxInteractions) {
        return true;
      } else {
        let nonZeroPanelIndexes = Object.keys(this.panelValuesByPanelIndex).filter(panelIndex => {
          return this.panelValuesByPanelIndex[panelIndex] > 0;
        });

        return nonZeroPanelIndexes.length > 0;
      }
    }

    update() {
      if (!this.cycle.clock.running) {
        this.cycle.start();
      }

      this.cycle.next();
    }

    onUpCycle(value) {
      this.currentValue = value;
    }

    onDownCycle(value) {
      this.currentValue = value;
    }

    getValueForPanel(panel) {
      if (!this.panelContext.isAtMaxInteractions) {
        let previousPanelValue = this.panelValuesByPanelIndex[panel.index];
        if (previousPanelValue <= 0.02) {
          // Due to the math below, some panels never actually hit 0 value. This forces a 0 value if it's close,
          // which ensures the panels reset to 0 if they're inactive.
          this.panelValuesByPanelIndex[panel.index] = 0;
          return 0;
        }
      }
      // but then it's also... looping somehow....
      // the value for the panel is like a value mod... hrm
      // 0,  1,  2,  3, ..., 20
      // 0, .1, .2,     ...,  1
      //
      // so, I have a value from 0...1
      // I want that spread out over all panels, but "loop" around
      // currentValue = .5
      // index = 2;
      // distance ratio = 2 / 20, .1
      // currentValue - distance ratio = .4
      let distanceRatio = panel.index / this.panelContext.panels.length;
      let wrappedValue = Math.abs(this.currentValue - distanceRatio);
      // console.log(wrappedValue);
      let value = 4 * wrappedValue;
      this.panelValuesByPanelIndex[panel.index] = value;
      return value;
    }
  }


  /***
   * Test infrastructure
   ***/

  const runTest = (name, fn) => {
    try {
      fn();
      console.log("\t" + name + ": passed");
    } catch (error) {
      console.log("\t" + name + ": failed: " + error);
    }
  };

  class Given {
    constructor(name, testInitFn) {
      this.name = name;
      this.testInitFn = testInitFn;
      this.testFns = [];
    }

    when(description, setupFn) {
      return new When(this, "when " + description, setupFn);
    }

    then(testFn) {
      return new When(this);
    }

    addTestFn(testFn) {
      this.testFns[this.testFns.length] = testFn;
    }

    runTestFns() {
      console.log("Given " + this.name);
      this.testFns.forEach(testFn => testFn());
    }
  }

  class When {
    constructor(given,
                description,
                setupFn) {
      this.given = given;
      this.description = description;
      this.setupFn = setupFn;
    }

    then(testFn) {
      this.given.addTestFn(() => {
        runTest(this.description, () => {
          let context = {};
          let subject = this.given.testInitFn(context);
          if (this.setupFn) {
            this.setupFn(subject, context);
          }
          testFn(subject, context);
        });
      });

      return this;
    }

    when(description, setupFn) {
      return new When(this.given, "when " + description, setupFn);
    }

    run() {
      this.given.runTestFns();
    }
  }

  const given = (name, setupFn) => {
    return new Given(name, setupFn);
  }

  const assertFalse = (value) => {
    if (value) {
      throw "expected value to be false, but was " + value;
    }
  }

  const assertTrue = (value) => {
    if (!value) {
      throw "expected value to be true, but was " + value;
    }
  }

  class Assertion {
    constructor(actualValue) {
      this.actualValue = actualValue;
    }

    isTrue() {
      assertTrue(this.actualValue);
    }

    isFalse() {
      assertFalse(this.actualValue);
    }

    equals(expectedValue) {
      assertEquals(this.actualValue, expectedValue);
    }

    isNull() {
      assertNull(this.actualValue);
    }
  }

  const assert = (actualValue) => {
    return new Assertion(actualValue);
  }

  class Run {
    constructor(fn) {
      this.fn = fn;
    }

    times(count) {
      for (let i = 0; i < count; i++) {
        this.fn();
      }
    }
  }

  const run = (fn) => new Run(fn);

  const assertEquals = (actualValue, expectedValue) => {
    if (expectedValue !== actualValue) {
      throw "Expected " + expectedValue + " but was " + actualValue;
    }
  }

  const assertNull = (actualValue) => {
    if (actualValue) {
      throw "Expected null, but was " + actualValue;
    }
  }

  const tests = [
    /**
     * Clock tests
     */
    given("Clock", () => new Clock())
      .when("initialized")
      .then((clock) => {
        assert(clock.running).isFalse();
        assert(clock.ticks).isNull();
      })
      .when("started", clock => { clock.start() })
      .then((clock) => {
        assert(clock.running).isTrue();
        assert(clock.ticks).isNull();
      })
      .when("next", clock => {
        clock.start();
        clock.next();
      })
      .then((clock) => {
        assert(clock.running).isTrue();
        assert(clock.startTick).equals(0);
        assert(clock.ticks).equals(0);
      })
      .when("clock has been running", clock => {
        clock.start();
        run(() => clock.next()).times(100);
      })
      .then(clock => {
        assert(clock.running).isTrue();
        assert(clock.startTick).equals(0);
        assert(clock.ticks).equals(99);
      })
      .when("clock is stopped", clock => {
        clock.start();
        run(() => clock.next()).times(100);
        clock.stop();
      })
      .then(clock => {
        assert(clock.running).isFalse();
        assert(clock.startTick).isNull();
        assert(clock.ticks).isNull();
      })
      .when("clock is restarted", clock => {
        clock.start();
        run(() => clock.next()).times(100);
        clock.restart();
        clock.next();
      })
      .then(clock => {
        assert(clock.running).isTrue();
        assert(clock.startTick).equals(0);
        assert(clock.ticks).equals(0);
      }),
    /**
     * Cycle tests
     */
    given("Cycle", (context) => {
      let onUpFn = (value) => {
        context.onUpFnValue = value;
      }
      let onDownFn = (value) => {
        context.onDownFnValue = value;
      }
      return new Cycle(100, onUpFn, onDownFn);
    })
      .when("initialized")
      .then(cycle=> {
        assert(cycle.iterations).equals(0);
      })
      .when("on first step of Cycle", (cycle) => {
        cycle.start();
        cycle.next();
      })
      .then((cycle, context) => {
        assert(cycle.iterations).equals(0);
        assert(cycle.clock.ticks).equals(0);
        assert(context.onUpFnValue).equals(0);
        assert(context.onDownFnValue).isNull();
      })
      .when("on second step of Cycle", (cycle) => {
        cycle.start();
        cycle.next();
        cycle.next();
      })
      .then((cycle, context) => {
        assert(cycle.iterations).equals(0);
        assert(cycle.clock.ticks).equals(1);
        assert(context.onUpFnValue).equals(0.02);
        assert(context.onDownFnValue).isNull();
      })
      .when("one step before halfway point in cycle", (cycle, context) => {
        cycle.start();
        cycle.clock.ticks = 48
        cycle.next();
      })
      .then((cycle, context) => {
        assert(cycle.iterations).equals(0);
        assert(cycle.clock.ticks).equals(49);
        assert(context.onUpFnValue).equals(.98);
        assert(context.onDownFnValue).isNull();
      })
      .when("halfway point in cycle", (cycle, context) => {
        cycle.start();
        cycle.clock.ticks = 49
        cycle.next();
      })
      .then((cycle, context) => {
        assert(cycle.iterations).equals(0);
        assert(cycle.clock.ticks).equals(50);
        assert(context.onUpFnValue).isNull();
        assert(context.onDownFnValue).equals(1)
      })
  ];

  tests.forEach(test => {
    test.run();
  })

  /***
   * Initialization
   ***/

  EVENT_LOOP_INFO_ELEMENT.value = "stopped";

  const MIN_REVERBERATION_DISTANCE = 2;
  const MAX_REVERBERATION_DISTANCE = 6;
  const REVERB_DELAY_TICKS = 20;
  const MIN_TRIGGER_PANEL_ANIMATION_LOOP_DURATION_TICKS = 200;
  const MAX_TRIGGER_PANEL_ANIMATION_LOOP_DURATION_TICKS = 500;
  const MAX_INTERACTION_THRESHOLD_PERCENT = .5;

  let interactionConfig = new InteractionConfig(
    MIN_REVERBERATION_DISTANCE,
    MAX_REVERBERATION_DISTANCE,
    REVERB_DELAY_TICKS,
    MIN_TRIGGER_PANEL_ANIMATION_LOOP_DURATION_TICKS,
    MAX_TRIGGER_PANEL_ANIMATION_LOOP_DURATION_TICKS,
    MAX_INTERACTION_THRESHOLD_PERCENT
  );

  let panelContext = new PanelContext(
    NUMBER_OF_PANELS,
    interactionConfig,
    getGradient()
  );

  function runScript() {
    let triggers = TRIGGER_SCRIPT_TEXTAREA.value.split("\n");
    triggers.forEach(trigger => {
      let triggerCmd = trigger.split(" ");
      let panelIndex = parseInt(triggerCmd[0]);
      let panel = panelContext.getPanelAt(panelIndex);
      if (panel) {
        setTimeout(
          () => panelContext.triggerPanel(panel),
          parseInt(triggerCmd[2])
        );
        setTimeout(
          () => panel.stopInteraction(),
          parseInt(triggerCmd[4])
        )
      }
    });
  }

  TRIGGER_SCRIPT_BUTTON.addEventListener("click", () => runScript());

  TRIGGER_WALK_DOWN_BUTTON.addEventListener("click", () => {
    const WALK_DELAY_BETWEEN_PANELS = 1000;
    for (let i = 0; i < NUMBER_OF_PANELS; i++) {
      let time = i * WALK_DELAY_BETWEEN_PANELS
      setTimeout(() => {
        let panel = panelContext.getPanelAt(i);
        panelContext.triggerPanel(panel);
      }, time);
      setTimeout(() => {
        let panel = panelContext.getPanelAt(i);
        panel.stopInteraction();
      }, time + (Math.random() * 6000));
    }
  });

  TRIGGER_MAX_BUTTON.addEventListener("click", () => {
    let numberOfPanels =
      (panelContext.panels.length * panelContext.interactionConfig.maxInteractionThresholdPercent) + 1;
    for (let i = 0; i < numberOfPanels; i++) {
      let panel = panelContext.getPanelAt(i);
      panelContext.triggerPanel(panel);
    }
  })


});


</script>
</body>
</html>