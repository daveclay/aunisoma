<html>
<body>
<style>
    body {
        background-color: black;
        font-family: monospace;
        color: gray;
    }
    #stage {
    }
    .panelContainer {
        display: inline-block;
        min-height: 1px;
    }
    .panel {
        display: block;
        width: 50px; /* 24" */
        height: 100px; /* 48" */
        background-color: rgb(60, 0, 0);
        border: 1px solid #222222;
        margin: 5px;
    }
    .panelInfo {
        display: block;
        width: 50px; /* 24" */
        height: 50px;
        overflow-x: clip;
        text-align: center;
        padding-left: 6px; /* align it center, for some reason */
    }
    .panelReverberationInfo {
        display: inline-block;
        width: 50px;
        height: 20px;
        margin: 5px;
        border: 1px solid #222222;
    }
    #panelTemplate {
        display: none;
    }
    .controlTable tr td {
        border: 1px solid #333333;
        vertical-align: top;
        padding: 5px;
    }
    .gradient-slice {
        display: inline-block;
        width: 1px;
        height: 100px;
    }
</style>
<div id="stage"></div>
<div id="panelTemplate" class="panelContainer">
    <div class="panel"></div>
    <div class="panelInfo">&nbsp;</div>
</div>
Click on a panel to simulate a person interacting with a panel. Click on the panel again to simulate a person walking away from the panel.
<hr/>
<table class="controlTable">
    <tr>
        <td>
            <p>
                <label for="triggerScript">Panel interaction script</label>
            </p>
            <textarea id="triggerScript" rows="10" cols="30">
3 at 0ms for 1500ms
8 at 200ms for 2000ms
6 at 500ms for 3000ms
7 at 600ms for 3000ms
9 at 1000ms for 5000ms
10 at 1500ms for 2000ms
11 at 2000ms for 2000ms
12 at 3000ms for 3000ms
</textarea>
            <p>
                <button id="triggerScriptButton" value="run">Run</button>
            </p>
        </td>
        <td>
            <p>
                Preset Scripts
            </p>
            <p>
                <button id="triggerWalkDownButton">Walk Left to Right</button>
            </p>
            <p>
                <button id="triggerMaxInteractionsButton">Max Interactions</button>
            </p>
            <p>
                <button id="clearInteractionsButton">Clear Interactions</button>
            </p>
        </td>
        <td>
            <p>
                Elapsed Time
            </p>
            <p id="elapsedTimeElement"></p>
            <p>
                Loop Time
            </p>
            <p id="loopTime"></p>
        </td>
        <td>
            <p>
                Current Power Draw: <span id="currentPowerDraw"></span>
            </p>
            <p>
                Max Power Draw: <span id="maxPowerDraw"></span>
            </p>
            <p>
                Ave Power Draw: <span id="averagePowerDraw"></span>
            </p>
        </td>
    </tr>
    <tr>
        <td colspan="4" id="gradientContainer">
        </td>
    </tr>
</table>
<div id="gradientTemplate"></div>
<script>
document.addEventListener("DOMContentLoaded", () => {

  /******************************************************************
   * Arduino.h
   *****************************************************************/

  HIGH = true;

  function abs(val) {
    return Math.abs(val);
  }

  function min(a, b) {
    return Math.min(a, b);
  }

  function max(a, b) {
    return Math.max(a, b);
  }

  function maybe(percent) {
    return Math.round(Math.random() * 100) > percent;
  }

  function round(value) {
    return Math.round(value);
  }

  function digitalRead(sensorPin) {
    let sensor = sensors[sensorPin - FIRST_INPUT_PIN];
    return sensor.active;
  }

  function setPanelColor(i, red, green, blue) {
    PANEL_UI_OBJECTS[i].setColor(red, green, blue);
  }

  /******************************************************************
   * Maths
   *****************************************************************/

  function constrain(minValue, maxValue, value) {
    return max(minValue, min(maxValue, value));
  }

  function interpolateValue(value_a, value_b, amount) {
    let value_a_amount = value_a * (1.0 - amount);
    let value_b_amount = value_b * amount;

    return round(Math.floor(value_a_amount) + Math.floor(value_b_amount));
  }

  /******************************************************************
   * Color
   *****************************************************************/

  const gamma8 = [
    0,   0,   0,   0,   1,   1,   1,   1,   1,   2,   2,   2,   3,   3,   3,   4,
    4,   4,   5,   5,   6,   6,   6,   7,   7,   8,   8,   9,   9,  10,  10,  11,
    11,  12,  12,  13,  14,  14,  15,  15,  16,  16,  17,  18,  18,  19,  20,  20,
    21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  28,  29,  30,  31,  31,
    32,  33,  34,  34,  35,  36,  37,  37,  38,  39,  40,  41,  41,  42,  43,  44,
    45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,
    59,  60,  61,  62,  63,  64,  65,  65,  66,  67,  68,  69,  70,  71,  72,  73,
    74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  88,  89,  90,
    91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 102, 103, 104, 105, 106, 107,
    108, 109, 110, 112, 113, 114, 115, 116, 117, 119, 120, 121, 122, 123, 124, 126,
    127, 128, 129, 130, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 144, 145,
    146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165,
    167, 168, 169, 171, 172, 173, 174, 176, 177, 178, 180, 181, 182, 184, 185, 187,
    188, 189, 191, 192, 193, 195, 196, 197, 199, 200, 202, 203, 204, 206, 207, 209,
    210, 211, 213, 214, 216, 217, 218, 220, 221, 223, 224, 226, 227, 228, 230, 231,
    233, 234, 236, 237, 239, 240, 242, 243, 245, 246, 248, 249, 251, 252, 254, 255
  ];

  class Color {
    constructor(red, green, blue) {
      this.red = red;
      this.green = green;
      this.blue = blue;
    }

    interpolate(color, amount) {
      let red = interpolateValue(this.red, color.red, amount);
      let green = interpolateValue(this.green, color.green, amount);
      let blue = interpolateValue(this.blue, color.blue, amount);

      return new Color(red, green, blue);
    }
  }

  /******************************************************************
   * GradientValuePoint
   *****************************************************************/

  class GradientValuePoint {
    constructor(value, colorValue) {
      this.value = value;
      this.colorValue = colorValue;
    }
  }

  /******************************************************************
   * SingleGradientValueMap
   *****************************************************************/

  class SingleGradientValueMap {
    constructor() {
      this.gradientValuePoints = []; // new ArrayList<GradientValuePoint>();
    }

    getColorAtValue(value) {
      let points = this.getGradientValuePointsForValue(value);

      // ratio = zero-based value / range
      // ratio = val - min / max - min;
      let min = points[0].value;
      let max = points[1].value;
      let ratio = (value - min) / (max - min);

      // ints
      let minColor = points[0].colorValue;
      let maxColor = points[1].colorValue;

      // int
      let colorRange = maxColor - minColor;
      // double
      let colorValue = colorRange * ratio;

      // int
      let color = minColor + Math.round(colorValue);
      return Math.min(255, Math.max(0, color));
    }


    getGradientValuePointsForValue(value) {
      let lowerPoint = null;
      let matchingPointsForValue = null;
      for (let i = 0; i < this.gradientValuePoints.length; i++) {
        let point = this.gradientValuePoints[i];
        if (value >= point.value) {
          lowerPoint = point;
        } else {
          if (lowerPoint == null) {
            matchingPointsForValue = [point, point];
          } else {
            matchingPointsForValue = [lowerPoint, point];
          }
          break;
        }
      }

      if (matchingPointsForValue) {
        return matchingPointsForValue;
      }

      // otherwise, use the max two points
      return [
        this.gradientValuePoints[this.gradientValuePoints.length - 2],
        this.gradientValuePoints[this.gradientValuePoints.length - 1]
      ];
    }

    addPoint(value, color) {
      let point = new GradientValuePoint(value, color);
      this.gradientValuePoints.push(point);
    }

    setGradientValuePoints(points) {
      this.gradientValuePoints = points;
    }

    reset() {
      this.gradientValuePoints.clear();
    }
  }

  /******************************************************************
   * GradientValueMap
   *****************************************************************/

  class GradientValueMap {

    constructor() {
      this.redMap = new SingleGradientValueMap();
      this.greenMap = new SingleGradientValueMap();
      this.blueMap = new SingleGradientValueMap();

      this.hueMap = new SingleGradientValueMap();
      this.saturationMap = new SingleGradientValueMap();
      this.lightnessMap = new SingleGradientValueMap();
    }

    reset() {
      this.redMap.reset();
      this.greenMap.reset();
      this.blueMap.reset();

      this.hueMap.reset();
      this.saturationMap.reset();
      this.lightnessMap.reset();
    }

    add_rgb_point(value, red, green, blue) {
      this.addRedPoint(value, red);
      this.addGreenPoint(value, green);
      this.addBluePoint(value, blue);

      let shiftedRed = red / 255;
      let shiftedGreen = green / 255;
      let shiftedBlue = blue / 255;

      let colorMax = Math.max(shiftedRed, shiftedGreen, shiftedBlue);
      let colorMin = Math.min(shiftedRed, shiftedGreen, shiftedBlue);

      let delta = colorMax - colorMin;
      let hue = 0;

      if (delta == 0) {
        hue = 0;
      } else if (colorMax == shiftedRed) {
        hue = ((shiftedGreen - shiftedBlue) / delta) % 6;
      } else if (colorMax == shiftedGreen) {
        hue = (shiftedBlue - shiftedRed) / delta + 2;
      } else {
        hue = (shiftedRed - shiftedGreen) / delta + 4;
      }

      hue = Math.round(hue * 60);

      if (hue < 0) {
        hue += 360;
      }

      let lightness = (colorMax + colorMin) / 2;

      let saturation = delta == 0 ? 0 : delta / (1 - Math.abs(2 * lightness - 1));

      // scale to 0 - 255
      saturation = + Math.round(saturation * 100);
      lightness = + Math.round(lightness * 100);

      this.hueMap.addPoint(value, hue);
      this.saturationMap.addPoint(value, saturation);
      this.lightnessMap.addPoint(value, lightness);
    }

    addRedPoint(value, color) {
      this.redMap.addPoint(value, color);
    }

    addGreenPoint(value, color) {
      this.greenMap.addPoint(value, color);
    }

    addBluePoint(value, color) {
      this.blueMap.addPoint(value, color);
    }

    getColorForValue(value) {
      let red = this.redMap.getColorAtValue(value);
      let green = this.greenMap.getColorAtValue(value);
      let blue = this.blueMap.getColorAtValue(value);

      let hue = this.hueMap.getColorAtValue(value);
      let saturation = this.saturationMap.getColorAtValue(value);
      let lightness = this.lightnessMap.getColorAtValue(value);

      return new Color(red, green, blue, hue, saturation, lightness);
    }
  }


  /******************************************************************
   * Range
   *****************************************************************/

  class Range {
    constructor(min, max) {
      this.min = min;
      this.max = max;
    }

    random_int_between() {
      return this.min + Math.round(Math.random() * (this.max - this.min));
    }
  }

  /******************************************************************
   * Clock
   *****************************************************************/

  class Clock {
    constructor() {
      this.running = false;
      this.ticks = -1;
    }

    stop() {
      this.running = false;
      this.ticks = -1;
    }

    start() {
      this.running = true;
    }

    restart() {
      this.running = true;
      this.ticks = -1;
    }

    next() {
      if (!this.running) {
        return;
      }

      if (this.ticks < 0) {
        this.ticks = 0;
      } else {
        this.ticks += 1;
      }
    }
  }

  /******************************************************************
   * Cycle
   *****************************************************************/
  const CYCLE_DIRECTION_UP = 1;
  const CYCLE_DIRECTION_DOWN = 2;

  const CYCLE_TYPE_UP = 1;
  const CYCLE_TYPE_UP_AND_DOWN = 2;

  class Cycle {

    constructor(duration_ticks,
                oneShot,
                cycleType,
                cycleHandler) {
      this.duration_ticks = 0;
      this.oneShot = false;
      this.cycleType;
      this.cycleHandler;
      this.clock;
      this.iterations = 0;

      this.duration_ticks = duration_ticks;
      this.oneShot = oneShot;
      this.cycleType = cycleType;
      this.cycleHandler = cycleHandler;
      this.clock = new Clock();
      this.iterations = 0;
    }

    next() {
      if (this.clock.ticks > -1 && this.clock.ticks >= this.duration_ticks) {
        this.iterations += 1;
        if (!this.oneShot) {
          this.clock.restart();
        }
      }
      if (this.iterations > 0 && this.oneShot) {
        return;
      }

      this.clock.next();
      let looping_elapsed_duration = this.clock.ticks % this.duration_ticks;

      if (this.cycleType == CYCLE_TYPE_UP) {
        let current_value = looping_elapsed_duration / this.duration_ticks;
        this.cycleHandler.value(current_value, CYCLE_DIRECTION_UP);
      } else {
        let half_animation_loop_duration_ticks = round(this.duration_ticks / 2);
        if (looping_elapsed_duration < half_animation_loop_duration_ticks) {
          let current_value = looping_elapsed_duration / half_animation_loop_duration_ticks;
          this.cycleHandler.value(current_value, CYCLE_DIRECTION_UP);
        } else {
          let current_value = (this.duration_ticks - looping_elapsed_duration) / half_animation_loop_duration_ticks;
          this.cycleHandler.value(current_value, CYCLE_DIRECTION_DOWN);
        }
      }
    }

    start() {
      this.clock.start();
    }

    stop() {
      this.clock.stop();
    }

    jumpToDownCycle() {
      if (this.duration_ticks >= this.clock.ticks) {
        this.clock.ticks = max(0, this.duration_ticks - this.clock.ticks);
      }
    }

    restart(new_duration_ticks) {
      if (new_duration_ticks) {
        this.duration_ticks = new_duration_ticks;
      }
      this.iterations = 0;
      this.clock.restart();
    }

    isAtZeroPoint() {
      return this.clock.ticks < 0 || (this.clock.ticks % this.duration_ticks == 0);
    }

    isDone() {
      return this.oneShot && this.iterations > 0;
    }
  }

  /******************************************************************
   * PanelReverberation
   *****************************************************************/

  class PanelReverberation {
    constructor(panel,
                sourcePanel,
                distanceFromTrigger,
                reverberationDistanceSource,
                config) {
      this.panel;
      this.sourcePanel;
      this.config;
      this.reverberationDistanceSource;
      this.isSourceInteraction;
      this.scale;
      this.cycle;
      this.currentValue;
      this.distanceFromTrigger;

      this.panel = panel;
      this.sourcePanel = sourcePanel;
      this.config = config;
      this.reverberationDistanceSource = reverberationDistanceSource;
      this.isSourceInteraction = panel.index == this.sourcePanel.index;
      this.scale = 0;
      let oneShot = !this.isSourceInteraction;
      this.cycle = new Cycle(config.initial_trigger_panel_animation_loop_duration_ticks,
        oneShot,
        CYCLE_TYPE_UP_AND_DOWN,
        this);
      this.currentValue = 0;
      this.distanceFromTrigger = distanceFromTrigger;
    }

    value(value, direction) {
      this.setValue(value);
      if (direction == CYCLE_DIRECTION_UP) {
        if (!this.sourcePanel.active && !this.cycle.isAtZeroPoint()) {
          this.cycle.jumpToDownCycle();
        }
      }
    }

    setValue(value) {
      this.currentValue = value * this.scale;
    }

    start() {
      this.scale = this.calculateScale();
      this.cycle.restart();
    }

    stop() {
      this.cycle.stop();
    }

    update() {
      this.cycle.next();
      if (this.isSourceInteraction && this.panel.active && this.isAnimationLoopDone()) {
        let newDurationTicks = this.config.getTriggerPanelAnimationLoopDurationTicks();
        this.cycle.restart(newDurationTicks);
      }
    }

    isDone() {
      if (this.isSourceInteraction && this.panel.active) {
        return false;
      }

      if (!this.cycle.clock.running) {
        return true;
      }

      return this.isAnimationLoopDone();
    }

    calculateScale() {
      if (this.isSourceInteraction) {
        return 1;
      } else {
        let maxDistance = this.reverberationDistanceSource.getReverberationDistance();
        return (maxDistance - this.distanceFromTrigger) / maxDistance;
      }
    }

    isAnimationLoopDone() {
      return this.cycle.isDone() || (this.cycle.iterations > 0 && this.cycle.isAtZeroPoint());
    }
  }

  /******************************************************************
   * Interaction
   *****************************************************************/

  class Interaction {
    constructor(sourcePanel,
                interactionConfig,
                panelContext) {

      this.sourcePanel;
      this.config;
      this.panel_context;
      this.clock;
      this.panelReverberationsByPanelIndex = [];
      this.eligible_panel_reverberations = [];
      this.idleAnimation;

      // the _current_ number of Panels that are reverberating to one side
      this.currentReverberatingDistance = 0;
      // the index of the first Panel to the left that is reverberating
      this.panel_reverberations_start_index = 0;
      // the index of the last Panel to the _right_ that is reverberatin
      this.panel_reverberations_end_index = 0;
      this.numberOfEligiblePanelReverberations = 0;
      this.panel_reverberations_still_active = false;
      this.source_panel_reverberation;

      this.sourcePanel = sourcePanel;
      this.config = config;
      this.panel_context = panelContext;
      this.clock = new Clock();
      this.source_panel_reverberation = new PanelReverberation(
        this.sourcePanel,
        this.sourcePanel,
        0,
        this,
        this.config);
      this._buildPanelReverberations();
      this.panel_reverberations_still_active = false;
    }

    getReverberationDistance() {
      return this.currentReverberatingDistance;
    }

    getDistanceFromTrigger(panel) {
      return abs(this.sourcePanel.index - panel.index);
    }

    start() {
      if (this.clock.running) {
        return;
      }

      this.clock.start();
      this._trigger_new_reverberation(true);
    }

    _trigger_new_reverberation(trigger_source_panel) {
      this.currentReverberatingDistance = this.config.get_reverberation_distance();
      this.numberOfEligiblePanelReverberations = 0;
      // Calculate which PanelReverberations to start. Because this is referencing them _by panel index_, the for
      // loop doesn't start at 0, but rather where we want the new reverberation to start, and goes till
      // source panel is 6, current distance is 2, start index = 6 - 2 = 4.
      let start = max(0,
        this.sourcePanel.index - this.currentReverberatingDistance);
      // source panel is 6, current distance is 2, start index = 6 + 2 = 8.
      let end = min(this.config.number_of_panels - 1,
        this.sourcePanel.index + this.currentReverberatingDistance); // don't go beyond the end
      // So panels reverberating would be 4, 5, 6, 7, 8. 2 panels on each side of Panel 6.
      // Picking eligible PanelReverberations from _all_ the PanelReverberations.
      for (let i = start; i <= end; i++) {
        let panelReverberation = this.panelReverberationsByPanelIndex[i];
        // TODO: we already calculated the distance based on the start and end indexes
        //if (this.currentReverberatingDistance >= panelReverberation.distanceFromTrigger) {
        this.eligible_panel_reverberations[this.numberOfEligiblePanelReverberations] = panelReverberation;
        this.numberOfEligiblePanelReverberations++;
        if (trigger_source_panel || !panelReverberation.isSourceInteraction) {
          panelReverberation.start();
        }
        //}
      }
    }

    stop() {
      if (!this.clock.running) {
        return;
      }
      this.clock.stop();
    }

    update() {
      if (!this.clock.running) {
        return;
      }
      this.clock.next();
      let last_panel_reverberation_alive = null;
      let numberOfAlivePanelReverberations = 0;
      // This is looping through _eligible_ panels, not _all_ panels.
      for (let i = 0; i < this.numberOfEligiblePanelReverberations; i++) {
        let panelReverberation = this.eligible_panel_reverberations[i];
        if (!panelReverberation.isDone()) {
          this._start_panel_reverberation(panelReverberation);
          if (panelReverberation.isDone()) {
            // maybe it's down now that it's been updated? TODO: is this necessary or will the next update() catch it?
            panelReverberation.stop();
          } else {
            numberOfAlivePanelReverberations++;
            last_panel_reverberation_alive = panelReverberation;
          }
        }
      }

      this.panel_reverberations_still_active = numberOfAlivePanelReverberations > 0;
      if (numberOfAlivePanelReverberations == 1 && last_panel_reverberation_alive.currentValue == 0 && this.sourcePanel.active && maybe(65)) {
        this.clock.restart();
        this._trigger_new_reverberation(false);
      }
    }

    _start_panel_reverberation(panel_reverberation) {
      let reverberation_panel_delay_ticks = this.config.reverberation_panel_delay_ticks;
      let delay_for_panel_to_start_ticks = panel_reverberation.distanceFromTrigger * reverberation_panel_delay_ticks;
      if (this.clock.ticks >= delay_for_panel_to_start_ticks) {
        if (!panel_reverberation.timer.clock.running) {
          // TODO: sometimes the PanelReverberation has not had start() called
          panel_reverberation.start();
        }
        panel_reverberation.update();
      }
    }

    isDead() {
      if (this.sourcePanel.active) {
        return false;
      }

      return !this.panel_reverberations_still_active;
    }

    get_value_for_panel(panel) {
      let panelReverberation = this.panelReverberationsByPanelIndex[panel.index];
      if (panelReverberation == null) {
        return 0;
      } else {
        return panelReverberation.currentValue;
      }
    }

    _buildPanelReverberations() {
      // These track the indexes when adding left and right Panels
      this.panel_reverberations_start_index = 100; // arbitrary max value
      this.panel_reverberations_end_index = 0;

      // Add the source Panel
      this.addPanelReverberation(this.source_panel_reverberation);

      // iterate through _all_ potential possible Panels that may reverberate. This is potential more than will be
      // assigned to this Interaction, as the source Panel may be on the end and have none to the left (or right).
      let from_index = this.sourcePanel.index;
      for (let i = 0; i < this.config.max_reverberation_distance; i++) {
        let distance_from_index = i + 1;
        let left_panel_index = from_index - distance_from_index;
        let right_panel_index = from_index + distance_from_index;

        if (left_panel_index >= 0) {
          let panel = this.panel_context.get_panel_at(left_panel_index);
          let panelReverberation = this.createPanelReverberation(
            panel,
            distance_from_index);
          this.addPanelReverberation(panelReverberation);
        }

        if (right_panel_index <= this.config.number_of_panels - 1) {
          let panel = this.panel_context.get_panel_at(right_panel_index);
          let panelReverberation = this.createPanelReverberation(
            panel,
            distance_from_index);
          this.addPanelReverberation(panelReverberation);
        }
      }
    }

    addPanelReverberation(panelReverberation) {
      let panelIndex = panelReverberation.panel.index;
      // NOTE! The array isn't 0-based, but indexed by the Panel index (this makes lookups by Panel easier).
      this.panelReverberationsByPanelIndex[panelIndex] = panelReverberation;

      // This tracks which index to _start_ looking up PanelReverberations and where to _stop_, since it is not
      // 0 based.
      if (panelIndex > this.panel_reverberations_end_index) {
        this.panel_reverberations_end_index = panelIndex;
      }

      if (panelIndex < this.panel_reverberations_start_index) {
        this.panel_reverberations_start_index = panelIndex;
      }
    }

    createPanelReverberation(panel, distanceFromTrigger) {
      return new PanelReverberation(
        panel,
        this.sourcePanel,
        distanceFromTrigger,
        this,
        this.config);
    }
  }

  class Config {
    constructor() {
    }

    init() {
      this.max_reverberation_distance = this.reverberation_distance_range.max;
      this.initial_trigger_panel_animation_loop_duration_ticks =
        (this.trigger_panel_animation_loop_duration_ticks_range.max + this.trigger_panel_animation_loop_duration_ticks_range.min) / 2;
    }

    getTriggerPanelAnimationLoopDurationTicks() {
      return this.trigger_panel_animation_loop_duration_ticks_range.random_int_between();
    }

    get_reverberation_distance() {
      return this.reverberation_distance_range.random_int_between();
    }
  }

  class Panel {
    constructor(index,
                idleColor) {
      this.index;
      this.idleColor;
      this.color;
      this.currentValue;
      this.active;

      this.index = index;
      this.idleColor = idleColor;
      this.color = idleColor;
      this.active = false;
      this.currentValue = 0;
    }

    reset() {
      this.color = this.idleColor;
      this.currentValue = 0;
    }
  }

  class Aunisoma {
    constructor(config,
                maxAnimationGradient,
                gradients,
                numberOfGradients,
                sensors) {
      this.numberOfPanels;
      this.sensors;

      this.currentGradient;
      this.activePercent;
      this.active_panel_count;

      this.config;
      this.gradients;
      this.numberOfGradients;
      this.panels = [];
      this.interactions_by_source_panel_index = [];
      this.transitionAnimation;
      this.current_gradient_index;
      this.next_gradient_index;
      this.maxGradientIndex;
      this.transitioned_during_current_intermediate_state;
      this.ticks_since_last_transition;
      this.interaction_panel_values = [];

      this.config = config;
      this.gradients = gradients;
      this.numberOfGradients = numberOfGradients;
      this.current_gradient_index = 0;
      this.next_gradient_index = 0;
      this.currentGradient = this.gradients[this.current_gradient_index];
      this.maxGradientIndex = this.numberOfGradients - 1;
      this.numberOfPanels = config.number_of_panels;
      this.sensors = sensors;
      this._calculate_next_gradient_index();
      this._create_panels();
      this._create_interactions();
      this.transitionAnimation = new TransitionAnimation(500, this);
      this.maxInteractionAnimation = new MaxInteractionAnimation(config.number_of_panels, this.panels, maxAnimationGradient);
      this.transitioned_during_current_intermediate_state = false;
      this.ticks_since_last_transition = 0;
    }

    get_panel_at(index) {
      return this.panels[index];
    }

    _calculate_next_gradient_index() {
      if (this.current_gradient_index == this.maxGradientIndex) {
          this.next_gradient_index = 1; // don't go back to the non-max gradient until max is reset?
      } else {
          // TODO: randomize this? transition colors look weird if they're random, but might be more interesting for engagement.
          this.next_gradient_index = this.current_gradient_index + 1;
      }
    }

    _create_panels() {
      for (let i = 0; i < this.numberOfPanels; i++) {
        let idle_color = this.currentGradient.getColorForValue(0);
        let panel = new Panel(i, idle_color);
        panel.index = i;
        panel.idleColor = idle_color;
        panel.color = idle_color;
        this.panels[i] = panel;
      }
    }

    _create_interactions() {
      for (let i = 0; i < this.numberOfPanels; i++) {
        let panel = this.panels[i];
        let interaction = new Interaction(panel, this.config, this);
        this.interactions_by_source_panel_index[panel.index] = interaction;
      }
    }

    read_sensors() {
      for (let i = 0; i < this.numberOfPanels; i++) {
        // panel index 0, sensor indexes are 0 and 1
        // panel index 2, sensor indexes are 4 and 5
        // panel index 10, sensors indexes are 20, 21
        let sensorIndexForPanel = i * 2;
        let sensorFront = this.sensors[sensorIndexForPanel];
        let sensorBack = this.sensors[sensorIndexForPanel + 1];

        let active = sensorFront.active || sensorBack.active;
        this._handle_panel_sensor(i, active);
      }
    }

    _handle_panel_sensor(panel_index, active) {
      let panel = this.panels[panel_index];
      if (active != panel.active) {
        panel.active = active;
        if (active) {
          let interaction = this.interactions_by_source_panel_index[panel.index];
          if (!interaction.clock.running) {
            interaction.start();
          }
        }
      }
    }

    event_loop() {
      this.read_sensors();
      this.active_panel_count = 0;

      // Zero-out the interaction panel values
      for (let i = 0; i < this.numberOfPanels; i++) {
        // TODO: combine these two outer loops?
        this.interaction_panel_values[i] = 0;
      }

      for (let i = 0; i < this.numberOfPanels; i++) {
        let interaction = this.interactions_by_source_panel_index[i];
        interaction.update();
        // now that the internal state has been updated, determine whether it is dead and stop it if necessary.
        if (interaction.isDead()) {
          // TODO: Should Interaction call stop() itself after update() is called, and then self can just ask?
          interaction.stop();
        } else {
          for (let j = 0; j < this.numberOfPanels; j++) {
            let panel = this.panels[j];
            this.interaction_panel_values[panel.index] += interaction.get_value_for_panel(panel);
          }
        }

        if (interaction.sourcePanel.active) {
          this.active_panel_count += 1;
        }
      }

      let activePercent = (this.active_panel_count) / (this.numberOfPanels);
      let is_at_max_interactions = activePercent >= this.config.max_interaction_threshold_percent;
      if (is_at_max_interactions) {
        if (!this.maxInteractionAnimation.active) {
          this.maxInteractionAnimation.start();
        }
      } else {
        let is_at_intermediate_interactions = activePercent >= this.config.intermediate_interaction_threshold_percent;
        if (is_at_intermediate_interactions) {
          if (!this.transitionAnimation.cycle.clock.running) {
            if (this.transitioned_during_current_intermediate_state) {
              this.ticks_since_last_transition += 1;
              if (this.ticks_since_last_transition > config.min_max_interaction_gradient_transition_duration
                  && maybe(config.odds_for_max_interaction_gradient_transition)) {
                  this._start_transition();
                  this.ticks_since_last_transition = 0;
              }
            } else {
              this._start_transition();
              this.transitioned_during_current_intermediate_state = true;
            }
          }
        } else {
          // reset state for max tracking
          this.transitioned_during_current_intermediate_state = false;
          this.ticks_since_last_transition = 0;
          if (this.current_gradient_index != 0 && !this.transitionAnimation.active) {
            // reset back to original gradient
            this.next_gradient_index = 0;
            this._start_transition();
          }
        }

        if (this.maxInteractionAnimation.active) {
          this.maxInteractionAnimation.active = false;
          // indicate that the max interaction should transition out
          this.maxInteractionAnimation.hasTransitionedOut = false;
          this.maxInteractionAnimation.transitionTicks = 0;
        }
      }

      if (this.maxInteractionAnimation.active) {
        this.maxInteractionAnimation.update();
      } else if (this.transitionAnimation.active) {
        this.transitionAnimation.update();
      }
      this._update_panels();
      if (!this.maxInteractionAnimation.hasTransitionedOut) {
        this.maxInteractionAnimation.updateTransition();
      }
    }

    _start_transition() {
      let gradient = this.gradients[this.next_gradient_index];
      this.transitionAnimation.start(gradient);
    }

    getCurrentGradient() {
      return this.currentGradient;
    }

    switch_to_next_gradient() {
      this.current_gradient_index = this.next_gradient_index;
      this._calculate_next_gradient_index();
      this.currentGradient = this.gradients[this.current_gradient_index];
      this.ticks_since_last_transition = 1;
    }

    _update_panels() {
      for (let i = 0; i < this.numberOfPanels; i++) {
        let panel = this.panels[i];
        this._update_panel(panel, this.interaction_panel_values[panel.index]);
      }
    }

    _update_panel(panel, total_panel_value) {
      panel.currentValue = total_panel_value;

      if (this.maxInteractionAnimation.active) {
        // TODO: use the total_panel_value for _something_?
        panel.color = this.maxInteractionAnimation.get_color(panel);
      } else {
        let color;
        if (this.transitionAnimation.active) {
          // Transitioning to new gradient
          color = this.transitionAnimation.get_color(total_panel_value);
        } else {
          // regular animation
          color = this.currentGradient.getColorForValue(total_panel_value);
        }

        if (!this.maxInteractionAnimation.hasTransitionedOut) {
          let fromColor = this.maxInteractionAnimation.panelColorByPanelIndex[panel.index];
          let transitionAmount = this.maxInteractionAnimation.get_transition_amount();
          color = fromColor.interpolate(color, transitionAmount);
        }

        panel.color = color;
      }
    }
  }

  DEBOUNCE_PIR_DELAY = 20; // ms debounce
  class Sensor {

    constructor() {
      this.active;
      this.lastDebounceTime;
      this.lastReading;

      this.active = false;
      this.lastDebounceTime = -1;
      this.lastReading = false;
    }

    update(reading) {
      let currentMillis = millis();
      if (this.lastReading != reading) {
        this.lastDebounceTime = currentMillis;
      }
      if ((currentMillis - this.lastDebounceTime) > DEBOUNCE_PIR_DELAY) {
        // whatever the reading is at, it's been there for longer than the debounce
        // delay, so take it as the actual current state:
        if (this.active != reading) {
          this.active = reading;
        }
      }

      this.lastReading = reading;
    }
  }

  class IdleAnimation {
    constructor(durationTicks) {
      this.active;
      this.cycle;
      this.current_value;
      this.gradient = gradient;

      this.cycle = new Cycle(durationTicks,
        false,
        CYCLE_TYPE_UP_AND_DOWN,
        this);

      this.current_value = 0;
      this.active = false;
    }

    value(value, direction) {
      this.current_value = value;
    }

    start() {
      this.cycle.restart();
      this.active = true;
    }

    update() {
      if (!this.active) {
        return;
      }

      this.cycle.next();
    }

    get_color(panel_value) {
      return this.gradient.getColorForValue(panel_value);
    }
  }

  class TransitionAnimation {
    constructor(durationTicks,
                transitionAnimationCallback) {
      this.active;
      this.cycle;
      this.transitionAnimationCallback;
      this.current_value;
      this.target_gradient;

      this.transitionAnimationCallback = transitionAnimationCallback;
      this.cycle = new Cycle(durationTicks,
        false,
        CYCLE_TYPE_UP,
        this);

      this.current_value = 0;
      this.active = false;
    }

    value(value, direction) {
      this.current_value = value;
    }

    start(new_target_gradient) {
      this.target_gradient = new_target_gradient;
      this.cycle.restart();
      this.active = true;
    }

    update() {
      if (!this.active) {
        return;
      }

      this.cycle.next();

      if (this.current_value >= .97) {
        // Done!
        this.transitionAnimationCallback.switch_to_next_gradient();
        this.cycle.stop();
        this.active = false;
      }
    }

    get_color(panel_value) {
      let current_gradient = this.transitionAnimationCallback.getCurrentGradient();
      let from_color = current_gradient.getColorForValue(panel_value);
      let to_color = this.target_gradient.getColorForValue(panel_value);

      let color = from_color.interpolate(to_color, this.current_value);

      return color;
    }
  }

  class MaxInteractionAnimation {

    constructor(numberOfPanels, panels, gradient) {
      this.numberOfPanels;
      this.panels;
      this.active;
      this.cycle;
      this.current_value;
      this.panelColorByPanelIndex = [];
      this.gradient = gradient;
      this.transitionTicks;
      this.hasTransitionedOut;

      this.numberOfPanels = numberOfPanels;
      this.panels = panels;
      this.cycle = new Cycle(100,
        false,
        CYCLE_TYPE_UP,
        this);
      this.current_value = 0;
      this.active = 0;
      this.transitionTicks = 0;
      this.transitionDuration = 100;
      this.hasTransitionedOut = true;
    }

    value(value, direction) {
      this.current_value = value;
    }

    start() {
      this.transitionTicks = -1;
      this.hasTransitionedOut = true;
      for (let i = 0; i < this.numberOfPanels; i++) {
        this.panelColorByPanelIndex[i] = this.panels[i].color;
      }
      this.cycle.restart();
      this.active = true;
    }

    update() {
      this.cycle.next();
      this.transitionTicks += 1;
    }

    get_transition_amount() {
      return this.transitionTicks / this.transitionDuration;
    }

    updateTransition() {
      this.transitionTicks += 1;
      this.hasTransitionedOut = this.transitionTicks >= this.transitionDuration;
    }

    get_color(panel) {
      // but then it's also... looping somehow....
      // the value for the panel is like a value mod... hrm
      // 0,  1,  2,  3, ..., 20
      // 0, .1, .2,     ...,  1
      //
      // so, I have a value from 0...1
      // I want that spread out over all panels, but "loop" around
      // currentValue = .5
      // index = 2;
      // distance ratio = 2 / 20, .1
      // currentValue - distance ratio = .4
      let distanceRatio = (panel.index / this.panelColorByPanelIndex.length);
      // let value = Math.abs(this.current_value - distanceRatio);
      let value = this.current_value + distanceRatio;
      if (value > 1) {
        value = value - 1;
      }

      let color = this.getColorForPanelAndValue(panel, value);
      this.panelColorByPanelIndex[panel.index] = color;
      return color;
    }

    getColorForPanelAndValue(panel, value) {
      let maxColor = this.gradient.getColorForValue(value);
      if (this.transitionTicks < this.transitionDuration) {
          let fromColor = this.panelColorByPanelIndex[panel.index];
          return fromColor.interpolate(maxColor, this.get_transition_amount());
      } else {
          return maxColor;
      }
    }
  }


  /******************************************************************
   * Aunisoma-Sketch.ino
   *****************************************************************/

  const FIRST_INPUT_PIN = 4 // 14 through 54 are PIR pins

  let sensors = [];

  let number_of_panels = 20;
  let config = new Config();

  let maxAnimationGradient = new GradientValueMap();
  let initial_gradient = new GradientValueMap();
  let blue_gradient = new GradientValueMap();
  let green_gradient = new GradientValueMap();
  let purple_red_gradient = new GradientValueMap();
  let green_blue_gradient = new GradientValueMap();

  let gradients = [
    initial_gradient,
    blue_gradient,
    purple_red_gradient,
    green_blue_gradient,
    green_gradient
  ];

  let aunisoma;

  function setup() {

    maxAnimationGradient.add_rgb_point(0.00,   255,   0,   0);
    maxAnimationGradient.add_rgb_point(0.02,   255, 127,   0);
    maxAnimationGradient.add_rgb_point(0.20,   255, 255,   0);
    maxAnimationGradient.add_rgb_point(0.29,   200, 255,   0);
    maxAnimationGradient.add_rgb_point(0.30,     0, 255,   0);
    maxAnimationGradient.add_rgb_point(0.31,     0, 255, 127);
    maxAnimationGradient.add_rgb_point(0.40,     0, 255, 200);
    maxAnimationGradient.add_rgb_point(0.45,     0, 255, 255);
    maxAnimationGradient.add_rgb_point(0.59,     0, 120, 255);
    maxAnimationGradient.add_rgb_point(0.60,     0,   0, 255);
    maxAnimationGradient.add_rgb_point(0.61,   160,   0, 255);
    maxAnimationGradient.add_rgb_point(0.80,   255,   0, 255);
    maxAnimationGradient.add_rgb_point(0.80,   255,   0, 255);
    maxAnimationGradient.add_rgb_point(0.89,   255,   0, 200);
    maxAnimationGradient.add_rgb_point(1.00,   255,   0,   0);

    initial_gradient.add_rgb_point(0.0, 3, 0, 0);
    initial_gradient.add_rgb_point(.4, 255, 0, 0);
    initial_gradient.add_rgb_point(1.0, 255, 255, 0);
    initial_gradient.add_rgb_point(1.6, 0, 255, 255);
    initial_gradient.add_rgb_point(3, 0, 255, 255);

    blue_gradient.add_rgb_point(0.0, 0, 0, 10);
    blue_gradient.add_rgb_point(.4, 0, 0, 255);
    blue_gradient.add_rgb_point(.8, 255, 0, 255);
    blue_gradient.add_rgb_point(2, 255, 255, 0);
    blue_gradient.add_rgb_point(3, 255, 255, 0);

    green_gradient.add_rgb_point(0.0, 0, 10, 0);
    green_gradient.add_rgb_point(.4, 0, 255, 0);
    green_gradient.add_rgb_point(.8, 255, 255, 0);
    green_gradient.add_rgb_point(1.5, 255, 0, 255);
    green_gradient.add_rgb_point(3, 255, 0, 255);

    purple_red_gradient.add_rgb_point(0,   1,    0,   1);
    purple_red_gradient.add_rgb_point(.4, 255,   0, 255);
    purple_red_gradient.add_rgb_point(.85,  255,   0,   0);
    purple_red_gradient.add_rgb_point(1.2,  255, 255,   0);
    purple_red_gradient.add_rgb_point(3,    0, 255,   0);

    green_blue_gradient.add_rgb_point(0,    0,   3,   0);
    green_blue_gradient.add_rgb_point(.3,   0, 255,   0);
    green_blue_gradient.add_rgb_point(1,    0, 255, 255);
    green_blue_gradient.add_rgb_point(2,    0,   0, 255);
    green_blue_gradient.add_rgb_point(3,  255,   0, 255);

    config.number_of_panels = number_of_panels;
    config.reverberation_distance_range = new Range(2, 5);
    // how long to wait to trigger a neighbor Panel to reverberate
    config.reverberation_panel_delay_ticks = 20;
    config.trigger_panel_animation_loop_duration_ticks_range = new Range(220, 300);
    config.max_interaction_threshold_percent = .85;
    config.intermediate_interaction_threshold_percent = .5;
    config.min_max_interaction_gradient_transition_duration = 5000;
    config.odds_for_max_interaction_gradient_transition = 90;

    config.init();

    for (let i = 0; i < 40; i++) {
      sensors[i] = new Sensor();
    }

    aunisoma = new Aunisoma(config, maxAnimationGradient, gradients, 5, sensors);
  }

  function loop() {
    let start = new Date().getTime();
    for (let i = 0; i < 40; i++) {
      let sensorPin = FIRST_INPUT_PIN + i;
      let panelActive = digitalRead(sensorPin) == HIGH;
      sensors[i].active = panelActive;
    }

    aunisoma.event_loop();

    for (let i = 0; i < number_of_panels; i++) {
      let panel = aunisoma.get_panel_at(i);
      let color = panel.color;
      setPanelColor(i, color.red, color.green, color.blue, color.hue, color.saturation, color.lightness);
    }

    LOOP_TIME_ELEMENT.innerText = Math.round(new Date().getTime() - start) + " ms";
  }

  /******************************************************************
   * Power Calculations/Utilities
   *****************************************************************/

    // TODO: capture average amp-hours over time for various interactions for nightly consumption
  const DRAW_PER_COLOR_PER_PANEL_AMPS = 0.8046715655;

  function calculatePowerDrawForColorAmps(color) {
    return (color / 255) * DRAW_PER_COLOR_PER_PANEL_AMPS;
  }

  function getPowerDrawAmps(red, green, blue) {
    return calculatePowerDrawForColorAmps(red)
      + calculatePowerDrawForColorAmps(green)
      + calculatePowerDrawForColorAmps(blue);
  }

  function addPowerDrawAmps(amps) {
    currentAmps += amps;
    totalAmps += amps;

    CURRENT_POWER_DRAW_ELEMENT.innerText = (currentAmps + "").substring(0, 4);
    if (currentAmps > maxAmps) {
      maxAmps = currentAmps;
      MAX_POWER_DRAW_ELEMENT.innerText = (maxAmps + "").substring(0, 4);
    }

    let averageAmps = totalAmps / iterations;
    AVERAGE_POWER_DRAW_ELEMENT.innerText = (averageAmps + "").substring(0, 4);
  }

  /******************************************************************
   * UI Code
   *****************************************************************/

  const PANEL_TEMPLATE_ELEMENT = document.getElementById("panelTemplate");
  const STAGE = document.getElementById("stage");

  const GRADIENT_CONTAINER_ELEMENT = document.getElementById("gradientContainer");
  const GRADIENT_TEMPLATE_ELEMENT = document.getElementById("gradientTemplate");

  const TRIGGER_SCRIPT_TEXTAREA = document.getElementById("triggerScript");
  const TRIGGER_SCRIPT_BUTTON = document.getElementById("triggerScriptButton");
  const TRIGGER_WALK_DOWN_BUTTON = document.getElementById("triggerWalkDownButton");
  document
    .getElementById("triggerMaxInteractionsButton")
    .addEventListener("click", () => triggerMaxInteraction());

  function triggerMaxInteraction() {
    let numberOfSensorsToTrigger = (config.max_interaction_threshold_percent * number_of_panels) + 1;
    let indexesToTrigger = {};
    while (Object.keys(indexesToTrigger).length < numberOfSensorsToTrigger) {
      let panelIndex;
      do {
        panelIndex = Math.min(19, Math.round(Math.random() * number_of_panels));
      } while (indexesToTrigger[panelIndex] != null);
      indexesToTrigger[panelIndex] = 1;
    }

    Object.keys(indexesToTrigger).forEach(s => {
      let i = parseInt(s);
      sensors[i*2].active = true;
      PANEL_UI_OBJECTS[i].setActive(true);
    });
  }

  document
    .getElementById("clearInteractionsButton")
    .addEventListener("click", () => {
      for (let i = 0; i < sensors.length; i++) {
        sensors[i].active = false;
      }
      for (let i = 0; i < PANEL_UI_OBJECTS.length; i++) {
        PANEL_UI_OBJECTS[i].setActive(false);
      }
    });


  const CURRENT_POWER_DRAW_ELEMENT = document.getElementById("currentPowerDraw");
  const MAX_POWER_DRAW_ELEMENT = document.getElementById("maxPowerDraw");
  const AVERAGE_POWER_DRAW_ELEMENT = document.getElementById("averagePowerDraw");

  const ELAPSED_TIME_ELEMENT = document.getElementById("elapsedTimeElement");
  const LOOP_TIME_ELEMENT = document.getElementById("loopTime")

  // TODO: show which panels have someone interacting
  const REVERBERATIONS_INFO_ELEMENT = document.getElementById("reverberationsInfo");
  const REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("reverberationInfoTemplate");
  const PANEL_REVERBERATION_INFO_TEMPLATE_ELEMENT = document.getElementById("panelReverberationInfoTemplate");

  function renderGradient(name, gradient, max) {
    let rgbGradientElement = clone(GRADIENT_TEMPLATE_ELEMENT);
    let hslGradientElement = clone(GRADIENT_TEMPLATE_ELEMENT);

    let steps = 1000;
    for (let i = 0; i < steps; i++) {

      let color;
      if (max) {
        color = gradient.getColorForValue(i / steps);
      } else {
        color = gradient.getColorForValue(i / (steps / 2));
      }

      let rgbSpan = document.createElement("span");
      rgbSpan.setAttribute("class", "gradient-slice");
      rgbSpan.style.backgroundColor = toHexString(color.red, color.green, color.blue);
      rgbGradientElement.appendChild(rgbSpan);

      /*
      let hslSpan = document.createElement("span");
      hslSpan.setAttribute("class", "gradient-slice");
      hslSpan.style.backgroundColor = toHSLString(color.hue, color.saturation, color.lightness);
      hslGradientElement.appendChild(hslSpan);
      */
    }

    let nameElement = document.createElement("p");
    nameElement.innerText = name;
    GRADIENT_CONTAINER_ELEMENT.appendChild(nameElement);
    GRADIENT_CONTAINER_ELEMENT.appendChild(rgbGradientElement);
    GRADIENT_CONTAINER_ELEMENT.appendChild(hslGradientElement);
  }

  function toHexString(red, green, blue) {
    return "#"
      + red.toString(16).padStart(2, "0")
      + green.toString(16).padStart(2, "0")
      + blue.toString(16).padStart(2, "0");
  }

  function toHSLString(hue, saturation, lightness) {
    return "hsl(" + hue + ", " + saturation + "%, " + lightness + "%)";
  }

  function clone(templateElement) {
    let clone = templateElement.cloneNode(true);
    clone.attributes.removeNamedItem("id");
    return clone;
  }

  function removeChildren(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  class PanelUI {
    constructor(index, panelElement) {
      this.index = index;
      this.panelElement = panelElement;
      this.panelUIElement = panelElement.querySelector("div[class='panel']");
      this.panelInfoElement = panelElement.querySelector("div[class='panelInfo']");
    }

    setActive(active) {
      if (active) {
        this.panelInfoElement.innerText = "Active";
      } else {
        this.panelInfoElement.innerHTML = "&nbsp;";
      }
    }

    setColor(red, green, blue, hue, saturation, lightness) {
      red = gamma8[red];
      green = gamma8[green];
      blue = gamma8[blue];
      // this.panelUIElement.style.backgroundColor = toHSLString(hue, saturation, lightness);
      this.panelUIElement.style.backgroundColor = toHexString(red, green, blue);
      addPowerDrawAmps(getPowerDrawAmps(red, green, blue));
    }
  }

  const PANEL_UI_OBJECTS = [];

  for (let i = 0; i < number_of_panels; i++) {
    let panelElement = clone(PANEL_TEMPLATE_ELEMENT);
    panelElement.classList.add("panel-" + i);
    STAGE.appendChild(panelElement);

    let panelUI = new PanelUI(i, panelElement);
    panelElement.addEventListener("click", () => {
      let sensor = sensors[i*2];
      sensor.active = !sensor.active;
      panelUI.setActive(sensor.active);
    });

    PANEL_UI_OBJECTS[i] = panelUI;
  }

  let currentAmps = 0;
  let maxAmps = 0;
  let totalAmps = 0;
  let iterations = 0;
  const START_TIME = new Date().getTime();

  setup();

  renderGradient("max_gradient", maxAnimationGradient,1);
  renderGradient("initial_gradient", initial_gradient);
  renderGradient("blue_gradient", blue_gradient);
  renderGradient("green_gradient", green_gradient);
  renderGradient("purple_red_gradient", purple_red_gradient);
  renderGradient("green_blue_gradient", green_blue_gradient);


  const mainRunInterval = setInterval(() => {
    currentAmps = 0;
    let elapsedSeconds = Math.round((new Date().getTime() - START_TIME) / 1000);
    if (elapsedSeconds > 59) {
      let elapsedMinutes = Math.round(elapsedSeconds / 60);
      ELAPSED_TIME_ELEMENT.innerText = elapsedMinutes + " minutes";
    } else {
      ELAPSED_TIME_ELEMENT.innerText = elapsedSeconds + " seconds";
    }

    loop();
    iterations++;
  }, 10);
});

</script>
</body>
</html>
